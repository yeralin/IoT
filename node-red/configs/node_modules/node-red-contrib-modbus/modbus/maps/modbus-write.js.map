{"version":3,"sources":["modbus-write.js"],"names":["module","exports","RED","require","install","mbCore","internalDebugLog","modbusClient","deregisterForModbus","config","mbBasics","createNode","this","name","showStatusActivities","unitid","ModbusWrite","nodes","dataType","Number","adr","node","setNodeStatusTo","getNode","server","bufferMessageList","registerForModbus","onModbusWriteDone","resp","msg","payload","onModbusWriteError","err","message","showErrors","error","getOriginalMessage","on","client","Object","prototype","hasOwnProperty","call","value","indexOf","JSON","parse","messageId","getObjectId","functionCodeModbusWrite","address","quantity","emit","_msgid","clear","done"],"mappings":"aAeAA,OAAOC,QAAU,SAAUC,GAEzBC,QAAQ,sBAAsBC,UAFhCJ,IAAOC,EAAUE,QAAUD,mBACzBG,EAAAF,QAAA,sBAIMG,EAAmBH,QAAQ,QAARA,CAAiB,uBAuFtCI,EAAAA,MAAAA,aAAaC,eArFjB,SAAsBC,GAJtBP,EAAMQ,MAAQC,WAAWC,KAAAH,GACzBG,KAAMP,KAASF,EAAQU,KAOrBD,KAAKE,qBAAuBL,EAAOK,qBANrCF,KAAMN,WAAgBG,EAAGN,WAEzBS,KAAAG,OAASC,EAAaP,OACpBP,KAAIe,SAAMN,EAAWO,SAErBN,KAAKC,IAALM,OAAkBV,EAAlBW,KACAR,KAAKE,SAAAA,EAAAA,SAGL,IAAKC,EAALH,KACAS,EAAKH,kBAAkBA,IAAAA,IACvBR,EAAAY,gBAAyBF,UAAzBC,GAGA,IAAMA,EAANnB,EAAAe,MAAAM,QAAAd,EAAAe,QACKC,IAOLlB,EAAamB,kBAAkBL,GAH/BX,EAAKH,uBAAcc,EAAAd,GAElBc,EAAAM,kBAAA,SAAAC,EAAAC,GAKKR,EAAKP,sBAJXP,EAAamB,gBAAAA,aAAbL,GAGAA,EAAKM,KAAAA,EAAAA,aAAoBN,EAAUO,kBAAWC,EAAAC,QAAAF,EAAAC,KAG3CR,EAAAU,mBAAA,SAAAC,EAAAH,GAMDvB,EAAiB0B,EAAIC,SAJjBZ,EAAJa,YALFb,EAAAc,MAAAH,EAAAH,GAQAR,EAAKU,eAAqBV,EAAAd,EAAoByB,EAAA3B,EAAA+B,mBAAAf,EAAAI,kBAAAI,KAE5CR,EAAAgB,GAAIhB,QAAKa,SAAYL,GACnBR,EAAWW,iBAAXH,IAHJtB,EAAA+B,SAWGC,OAAAC,UAAAC,eAAAC,KAAAb,EAAAC,QAAA,UAQ8B,iBAAtBD,EAAIC,QAAQa,QANK,SAArBpC,EAAAA,QAAa+B,OAAQ,UAAAT,EAAAC,QAAAa,MACxBd,EAAAC,QAAAa,MAAA,SAAAd,EAAAC,QAAAa,OAGF,EAAAd,EAAAC,QAAAa,MAAAC,QAAA,OAOMf,EAAIC,QAAQa,MAAQE,KAAKC,MAAMjB,EAAIC,QAAQa,SAF9Cd,EAFDkB,UAEO1C,EAAA2C,cACL3B,EAAAI,kBAAgBkB,IAAMC,EAAAA,UAAgBf,GAErCA,EAAA,CACFC,QAAA,CACFa,MAAAd,EAAAC,QAAAa,OAAAd,EAAAC,QAQGf,OAAQM,EAAKN,OANbgC,GAAAA,EAAJE,wBAAA5B,EAAAH,UACIgC,QAACzB,EAAAA,IAEF0B,SAAG9B,EAAA8B,SACJrB,UAASD,EAAAkB,WAEPhC,OAAMc,EAAER,QAGR8B,EAAQC,KAAM,cALPvB,EAAAR,EAAAM,kBAAAN,EAAAU,oBADLV,EAAAP,sBASJuC,EAAQxB,gBAAIwB,EAAAA,mBAAAA,MAKdhC,EAAAgB,GAAIhB,QAAKP,SAAAA,GACPJ,EAAAA,gBAASY,SAAgBf,GAC1Bc,EAAAI,kBAAA6B,QAxCH/C,EAAAC,oBAAAa,EAAAkC","file":"../modbus-write.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019 Klaus Landsdorf (https://bianco-royal.com/)\n Copyright 2016 - Jason D. Harper, Argonne National Laboratory\n Copyright 2015,2016 - Mika Karaila, Valmet Automation Inc.\n All rights reserved.\n node-red-contrib-modbus\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n **/\n/**\n * Modbus Write node.\n * @module NodeRedModbusWrite\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const mbCore = require('./core/modbus-core')\n  const internalDebugLog = require('debug')('contribModbus:write')\n\n  function ModbusWrite (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n\n    this.unitid = config.unitid\n    this.dataType = config.dataType\n    this.adr = Number(config.adr)\n    this.quantity = config.quantity\n\n    const node = this\n    node.bufferMessageList = new Map()\n    mbBasics.setNodeStatusTo('waiting', node)\n\n    const modbusClient = RED.nodes.getNode(config.server)\n    if (!modbusClient) {\n      return\n    }\n    modbusClient.registerForModbus(node)\n    mbBasics.initModbusClientEvents(node, modbusClient)\n\n    node.onModbusWriteDone = function (resp, msg) {\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo('write done', node)\n      }\n\n      node.send(mbCore.buildMessage(node.bufferMessageList, msg.payload, resp, msg))\n    }\n\n    node.onModbusWriteError = function (err, msg) {\n      internalDebugLog(err.message)\n      if (node.showErrors) {\n        node.error(err, msg)\n      }\n      mbBasics.setModbusError(node, modbusClient, err, mbCore.getOriginalMessage(node.bufferMessageList, msg))\n    }\n\n    node.on('input', function (msg) {\n      if (mbBasics.invalidPayloadIn(msg)) {\n        return\n      }\n\n      if (!modbusClient.client) {\n        return\n      }\n\n      /* HTTP requests for boolean and multiple data string [1,2,3,4,5] */\n      if (Object.prototype.hasOwnProperty.call(msg.payload, 'value') &&\n        typeof msg.payload.value === 'string') {\n        if (msg.payload.value === 'true' || msg.payload.value === 'false') {\n          msg.payload.value = (msg.payload.value === 'true')\n        } else {\n          if (msg.payload.value.indexOf(',') > -1) {\n            msg.payload.value = JSON.parse(msg.payload.value)\n          }\n        }\n      }\n\n      msg.messageId = mbCore.getObjectId()\n      node.bufferMessageList.set(msg.messageId, msg)\n\n      msg = {\n        payload: {\n          value: msg.payload.value || msg.payload,\n          unitid: node.unitid,\n          fc: mbCore.functionCodeModbusWrite(node.dataType),\n          address: node.adr,\n          quantity: node.quantity,\n          messageId: msg.messageId\n        },\n        _msgid: msg._msgid\n      }\n\n      modbusClient.emit('writeModbus', msg, node.onModbusWriteDone, node.onModbusWriteError)\n\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo(modbusClient.actualServiceState, node)\n      }\n    })\n\n    node.on('close', function (done) {\n      mbBasics.setNodeStatusTo('closed', node)\n      node.bufferMessageList.clear()\n      modbusClient.deregisterForModbus(node, done)\n    })\n  }\n\n  RED.nodes.registerType('modbus-write', ModbusWrite)\n}\n"]}