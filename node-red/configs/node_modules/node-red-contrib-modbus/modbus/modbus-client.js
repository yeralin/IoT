"use strict";module.exports=function(o){require("source-map-support").install();var r=require("./modbus-basics"),a=require("./core/modbus-client-core"),c=require("./core/modbus-queue-core");o.nodes.registerType("modbus-client",function(e){o.nodes.createNode(this,e);var t=require("modbus-serial");this.clienttype=e.clienttype,this.bufferCommands=e.bufferCommands,this.stateLogEnabled=e.stateLogEnabled,this.tcpHost=e.tcpHost,this.tcpPort=parseInt(e.tcpPort)||502,this.tcpType=e.tcpType,this.serialPort=e.serialPort,this.serialBaudrate=e.serialBaudrate,this.serialDatabits=e.serialDatabits,this.serialStopbits=e.serialStopbits,this.serialParity=e.serialParity,this.serialType=e.serialType,this.serialConnectionDelay=parseInt(e.serialConnectionDelay)||500,this.unit_id=parseInt(e.unit_id)||1,this.commandDelay=parseInt(e.commandDelay)||1,this.clientTimeout=parseInt(e.clientTimeout)||1e3,this.reconnectTimeout=parseInt(e.reconnectTimeout)||2e3,this.reconnectOnTimeout=e.reconnectOnTimeout,this.parallelUnitIdsAllowed=e.parallelUnitIdsAllowed;var s=this;function n(e){o.settings.verbose&&s.warn("Client -> "+e+s.serverInfo)}function i(e){o.settings.verbose&&a.internalDebug("Client -> "+e+s.serverInfo)}s.isFirstInitOfConnection=!0,s.closingModbus=!1,s.client=null,s.bufferCommandList=new Map,s.sendAllowed=new Map,s.unitSendingAllowed=[],s.sendToDeviceAllowed=[],s.messageAllowedStates=a.messagesAllowedStates,s.serverInfo="",s.stateMachine=null,s.stateService=null,s.stateMachine=a.createStateMachineService(),s.actualServiceState=s.stateMachine.initialState,s.actualServiceStateBefore=s.actualServiceState,s.stateService=a.startStateService(s.stateMachine),s.setUnitIdFromPayload=function(e){var t=parseInt(e.payload.unitid);Number.isInteger(t)?(s.client.setID(t),e.queueUnitId=t):(a.checkUnitId(s.unit_id,s.clienttype)||(s.unit_id=1),s.client.setID(s.unit_id),e.queueUnitId=s.unit_id)},!Number.isNaN(s.unit_id)&&a.checkUnitId(s.unit_id,s.clienttype)||(s.unit_id=1),s.updateServerinfo=function(){"tcp"===s.clienttype?s.serverInfo=" TCP@"+s.tcpHost+":"+s.tcpPort:s.serverInfo=" Serial@"+s.serialPort+":"+s.serialBaudrate+"bit/s",s.serverInfo+=" default Unit-Id: "+s.unit_id},s.queueLog=function(e){s.bufferCommands&&i(e)},s.stateService.subscribe(function(e){if(s.actualServiceStateBefore=s.actualServiceState,function(e){s.stateLogEnabled&&i(e)}((s.actualServiceState=e).value),e.matches("init")){s.updateServerinfo(),c.initQueue(s);try{s.isFirstInitOfConnection?(s.isFirstInitOfConnection=!1,setTimeout(s.connectClient,500)):setTimeout(s.connectClient,s.reconnectTimeout)}catch(e){s.error(e,{payload:"client connection error"})}n("reconnect in "+s.reconnectTimeout+" ms"),s.emit("mbinit")}e.matches("connected")&&(s.emit("mbconnected"),s.stateService.send("ACTIVATE")),e.matches("activated")&&(s.emit("mbactive"),s.bufferCommands&&s.stateService.send("QUEUE")),e.matches("queueing")&&(setTimeout(function(){c.dequeueCommand(s)},s.commandDelay),s.emit("mbqueue")),e.matches("opened")&&s.emit("mbopen"),e.matches("closed")&&(s.emit("mbclosed"),s.stateService.send("BREAK")),e.matches("failed")&&(s.emit("mberror","FSM Reset On State "+JSON.stringify(e)),s.stateService.send("BREAK")),e.matches("broken")&&(s.emit("mbbroken"),s.reconnectOnTimeout?(s.reconnectTimeout<=0&&(s.reconnectTimeout=2e3),n("try to reconnect by init in "+s.reconnectTimeout+" ms"),setTimeout(function(){s.stateService.send("INIT")},s.reconnectTimeout)):(n("stay active on broken state without reconnecting"),s.stateService.send("ACTIVATE")))}),s.connectClient=function(){if(s.client)try{s.client.close(function(){i("connection closed")})}catch(e){i(e.message)}if(s.client=null,s.client=new t,s.clientTimeout||(s.clientTimeout=1e3),s.reconnectTimeout||(s.reconnectTimeout=2e3),"tcp"===s.clienttype){if(!a.checkUnitId(s.unit_id,s.clienttype))return s.error(new Error("wrong unit-id (0..255)"),{payload:s.unit_id}),void s.stateService.send("FAILURE");switch(s.tcpType){case"C701":i("C701 port UDP bridge"),s.client.connectC701(s.tcpHost,{port:s.tcpPort,autoOpen:!0}).then(s.setTCPConnectionOptions).then(s.setTCPConnected).catch(s.modbusTcpErrorHandling);break;case"TELNET":i("Telnet port"),s.client.connectTelnet(s.tcpHost,{port:s.tcpPort,autoOpen:!0}).then(s.setTCPConnectionOptions).catch(s.modbusTcpErrorHandling);break;case"TPC-RTU-BUFFERED":i("TCP RTU buffered port"),s.client.connectTcpRTUBuffered(s.tcpHost,{port:s.tcpPort,autoOpen:!0}).then(s.setTCPConnectionOptions).catch(s.modbusTcpErrorHandling);break;default:i("TCP port"),s.client.connectTCP(s.tcpHost,{port:s.tcpPort,autoOpen:!0}).then(s.setTCPConnectionOptions).catch(s.modbusTcpErrorHandling)}}else{if(!a.checkUnitId(s.unit_id,s.clienttype))return s.error(new Error("wrong unit-id serial (1..247)"),{payload:s.unit_id}),void s.stateService.send("FAILURE");if(s.serialConnectionDelay||(s.serialConnectionDelay=500),!s.serialPort)return s.error(new Error("wrong serial port"),{payload:s.serialPort}),void s.stateService.send("FAILURE");var e={baudRate:parseInt(s.serialBaudrate),dataBits:parseInt(s.serialDatabits),stopBits:parseInt(s.serialStopbits),parity:s.serialParity,autoOpen:!1};switch(s.serialType){case"ASCII":i("ASCII port serial"),s.client.connectAsciiSerial(s.serialPort,e).then(s.setSerialConnectionOptions).catch(s.modbusSerialErrorHandling);break;case"RTU":i("RTU port serial"),s.client.connectRTU(s.serialPort,e).then(s.setSerialConnectionOptions).catch(s.modbusSerialErrorHandling);break;default:i("RTU buffered port serial"),s.client.connectRTUBuffered(s.serialPort,e).then(s.setSerialConnectionOptions).catch(s.modbusSerialErrorHandling)}}},s.setTCPConnectionOptions=function(){s.client.setID(s.unit_id),s.client.setTimeout(s.clientTimeout),s.stateService.send("CONNECT")},s.setTCPConnected=function(){a.modbusSerialDebug("modbus tcp connected on "+s.tcpHost)},s.setSerialConnectionOptions=function(){s.stateService.send("OPENSERIAL"),setTimeout(s.openSerialClient,parseInt(s.serialConnectionDelay))},s.modbusErrorHandling=function(e){e.message?a.modbusSerialDebug("modbusErrorHandling:"+e.message):a.modbusSerialDebug("modbusErrorHandling:"+JSON.stringify(e)),e.errno&&a.networkErrors.includes(e.errno)&&s.stateService.send("FAILURE")},s.modbusTcpErrorHandling=function(e){e.message?a.modbusSerialDebug("modbusTcpErrorHandling:"+e.message):a.modbusSerialDebug("modbusTcpErrorHandling:"+JSON.stringify(e)),e.errno&&a.networkErrors.includes(e.errno)&&s.stateService.send("FAILURE")},s.modbusSerialErrorHandling=function(e){e.message?a.modbusSerialDebug("modbusSerialErrorHandling:"+e.message):a.modbusSerialDebug("modbusSerialErrorHandling:"+JSON.stringify(e)),s.stateService.send("FAILURE")},s.openSerialClient=function(){"opened"===s.actualServiceState.value?(i("time to open Unit "+s.unit_id),a.modbusSerialDebug("modbus connection opened"),s.client.setID(s.unit_id),s.client.setTimeout(parseInt(s.clientTimeout)),s.client._port.on("close",s.onModbusClose),s.stateService.send("CONNECT")):(i("wrong state on connect serial "+s.actualServiceState.value),a.modbusSerialDebug("modbus connection not opened state is %s",s.actualServiceState.value),s.stateService.send("FAILURE"))},s.onModbusClose=function(){n("modbus closed port"),a.modbusSerialDebug("modbus closed port"),s.stateService.send("CLOSE")},s.on("readModbus",function(e,t,n){var i=s.actualServiceState;-1!==s.messageAllowedStates.indexOf(i.value)?s.bufferCommands?(e.queueNumber=c.getQueueNumber(s,e),c.pushToQueueByUnitId(s,a.readModbus,e,t,n),s.stateService.send("QUEUE"),s.queueLog(JSON.stringify({info:"queue read msg",message:e.payload,state:i.value,queueLength:s.bufferCommandList.get(e.queueUnit).length}))):a.readModbus(s,e,t,n):n(new Error("FSM Not Ready To Read At State "+i.value),e)}),s.on("writeModbus",function(e,t,n){var i=s.actualServiceState;-1!==s.messageAllowedStates.indexOf(i.value)?s.bufferCommands?(e.queueNumber=c.getQueueNumber(s,e),c.pushToQueueByUnitId(s,a.writeModbus,e,t,n),s.stateService.send("QUEUE"),s.queueLog(JSON.stringify({info:"queue write msg",message:e.payload,state:i.value,queueLength:s.bufferCommandList.get(e.queueUnit).length}))):a.writeModbus(s,e,t,n):n(new Error("FSM Not Ready To Write At State "+i.value),e)}),s.activateSending=function(e){var t=s.sendToDeviceAllowed.shift();s.bufferCommands&&(s.sendAllowed.set(e.queueUnit,!0),s.queueLog(JSON.stringify({info:"queue response activate sending",message:e.payload,queueLength:s.bufferCommandList.length,serialUnitId:t}))),s.stateService.send("ACTIVATE")},i("initialized"),s.setMaxListeners(0),s.on("reconnect",function(){s.stateService.send("FAILURE"),s.stateService.send("CLOSE")}),s.on("dynamicReconnect",function(e){if(r.invalidPayloadIn(e))throw new Error("Message Or Payload Not Valid");a.internalDebug("Dynamic Reconnect Parameters "+JSON.stringify(e.payload)),a.setNewNodeSettings(s,e),a.internalDebug("Dynamic Reconnect Starts on actual state "+s.actualServiceState.value),s.stateService.send("CLOSE")}),s.on("close",function(t){s.stateService.send("FAILURE"),s.stateService.send("CLOSE"),s.stateService.send("STOP"),i("close node"),s.client?s.client.close(function(){i("connection closed"),t()}).catch(function(e){i(e.message),t()}):t()}),s.registeredNodeList={},s.registerForModbus=function(e){s.registeredNodeList[e.id]=e,1===Object.keys(s.registeredNodeList).length&&(s.closingModbus=!1,s.stateService.send("INIT"))},s.deregisterForModbus=function(e,t){delete s.registeredNodeList[e.id],s.closingModbus&&t(),0===Object.keys(s.registeredNodeList).length?(s.closingModbus=!0,s.client?s.client.close(function(){s.stateService.send("CLOSE"),s.stateService.send("BREAK"),s.stateService.send("STOP"),t()}).catch(function(e){s.stateService.send("FAILURE"),s.stateService.send("STOP"),i(e.message),t()}):t()):t()}}),o.httpAdmin.get("/modbus/serial/ports",o.auth.needsPermission("serial.read"),function(e,t){require("serialport").list().then(function(e){t.json(e)}).catch(function(e){a.internalDebug(e.message)})})};
//# sourceMappingURL=maps/modbus-client.js.map
