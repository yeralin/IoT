{"version":3,"sources":["core/modbus-io-core.js"],"names":["require","install","de","biancoroyal","modbus","io","core","internalDebug","LineByLineReader","nameValuesFromIOFile","node","msg","values","response","readingOffset","valueNames","ioCore","ioFile","configData","forEach","mapping","push","buildInputAddressMapping","Number","addressOffset","logIOActivities","buildOutputAddressMapping","valueAddress","startsWith","allValueNamesFromIOFile","ioNode","insertValues","getDataTypeFromFirstCharType","type","registerName","offset","logging","addressStart","coilStart","bits","bitAddress","name","substring","registerType","addressType","split","Math","floor","addressStartIO","addressOffsetIO","Bit","dataType","error","register","registerAddress","index","item","prototype","hasOwnProperty","call","JSON","stringify","value","pow","getValueFromBufferByDataType","bufferOffset","responseBuffer","registerLength","length","readUInt16BE","isRegisterSizeWrong","readInt8","readInt16BE","convertedValue","readIntBE","readFloatBE","readDoubleBE","readUInt32BE","readUIntBE","convertValuesByType","Object","readInt32BE","buffer","err","message","filterValueNames","fc","adr","quantity","functionType","startRegister","endRegister","filter","valueName","start","sizeDivisor","sixteenBitBufferLength","buildMessageWithIO","bufferMessageList","origMsg","payload","rawMsg","assign","lastUpdatedAt","parseInt","this","allValueNames","address","module","exports"],"mappings":"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","file":"../../core/modbus-io-core.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019 Klaus Landsdorf (https://bianco-royal.com/)\n All rights reserved.\n node-red-contrib-modbus\n node-red-contrib-modbusio\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n'use strict'\nrequire('source-map-support').install()\n\nvar de = de || { biancoroyal: { modbus: { io: { core: {} } } } } // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.io.core.internalDebug = de.biancoroyal.modbus.io.core.internalDebug || require('debug')('contribModbus:io:core') // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.io.core.LineByLineReader = de.biancoroyal.modbus.io.core.LineByLineReader || require('line-by-line') // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.io.core.core = de.biancoroyal.modbus.io.core.core || require('./modbus-core') // eslint-disable-line no-use-before-define\n\nde.biancoroyal.modbus.io.core.nameValuesFromIOFile = function (node, msg, values, response, readingOffset) {\n  let valueNames = []\n  const ioCore = de.biancoroyal.modbus.io.core\n\n  if (node.ioFile && node.ioFile.configData) {\n    node.ioFile.configData.forEach(function (mapping) {\n      if (mapping.valueAddress && mapping.valueAddress.startsWith('%I')) {\n        valueNames.push(ioCore.buildInputAddressMapping('MB-INPUTS', mapping, Number(node.ioFile.addressOffset), Number(readingOffset), node.logIOActivities))\n      }\n\n      if (mapping.valueAddress && mapping.valueAddress.startsWith('%Q')) {\n        valueNames.push(ioCore.buildOutputAddressMapping('MB-OUTPUTS', mapping, Number(node.ioFile.addressOffset), Number(readingOffset), node.logIOActivities))\n      }\n    })\n  }\n\n  valueNames = ioCore.insertValues(valueNames, values, node.logIOActivities)\n\n  return ioCore.convertValuesByType(valueNames, values, response, node.logIOActivities)\n}\n\nde.biancoroyal.modbus.io.core.allValueNamesFromIOFile = function (ioNode) {\n  const valueNames = []\n  const ioCore = de.biancoroyal.modbus.io.core\n\n  if (ioNode && ioNode.configData) {\n    ioNode.configData.forEach(function (mapping) {\n      if (mapping.valueAddress && mapping.valueAddress.startsWith('%I')) {\n        valueNames.push(ioCore.buildInputAddressMapping('MB-INPUTS', mapping, Number(ioNode.addressOffset), 0))\n      }\n\n      if (mapping.valueAddress && mapping.valueAddress.startsWith('%Q')) {\n        valueNames.push(ioCore.buildOutputAddressMapping('MB-OUTPUTS', mapping, Number(ioNode.addressOffset), 0))\n      }\n    })\n  }\n\n  return valueNames\n}\n\nde.biancoroyal.modbus.io.core.getDataTypeFromFirstCharType = function (type) {\n  switch (type) {\n    case 'w':\n      return 'Word'\n    case 'd':\n      return 'Double'\n    case 'r':\n      return 'Real'\n    case 'f':\n      return 'Float'\n    case 'i':\n      return 'Integer'\n    case 'l':\n      return 'Long'\n    case 'b':\n      return 'Boolean'\n    default:\n      return 'Unsigned Integer'\n  }\n}\n\nde.biancoroyal.modbus.io.core.buildInputAddressMapping = function (registerName, mapping, offset, readingOffset, logging) {\n  const ioCore = de.biancoroyal.modbus.io.core\n  let addressStart = 0\n  let coilStart = 0\n  let addressOffset = 0\n  let bits = 0\n  let bitAddress = null\n\n  const type = mapping.name.substring(0, 1)\n  const registerType = mapping.valueAddress.substring(2, 3)\n  const addressType = mapping.valueAddress.substring(0, 3)\n\n  switch (type) {\n    case 'w': // word\n    case 'u': // unsigned integer\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 1\n      bits = 16\n      break\n    case 'i': // integer\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n\n      if (registerType === 'W') {\n        addressOffset = 1\n        bits = 16\n      } else {\n        addressOffset = 2\n        bits = 32\n      }\n      break\n    case 'r': // real\n    case 'f': // float\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 2\n      bits = 32\n      break\n    case 'd': // double\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 4\n      bits = 64\n      break\n    case 'l': // long\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 5\n      bits = 80\n      break\n    case 'b': // bit - boolean\n      if (registerType === 'X') {\n        bitAddress = mapping.valueAddress.split('%IX')[1].split('.')\n        addressStart = Math.floor(Number(bitAddress[0]) / 2)\n        coilStart = Number(bitAddress[0]) * 8 + Number(bitAddress[1])\n        addressOffset = 1\n        bits = 1\n      }\n      break\n    default:\n      if (logging) {\n        ioCore.internalDebug('unknown input type ' + type)\n      }\n      bits = 0\n  }\n\n  if (bits) {\n    const addressStartIO = addressStart - (Number(offset) || 0)\n\n    return {\n      register: registerName,\n      name: mapping.name,\n      addressStart: addressStart,\n      addressOffset: addressOffset,\n      addressOffsetIO: Number(offset) || 0,\n      addressStartIO: addressStartIO,\n      registerAddress: addressStartIO - Number(readingOffset),\n      coilStart: coilStart,\n      bitAddress: bitAddress,\n      Bit: (bitAddress) ? (Number(bitAddress[0]) * 8) + Number(bitAddress[1]) : 0,\n      bits: bits,\n      dataType: ioCore.getDataTypeFromFirstCharType(type),\n      type: 'input'\n    }\n  }\n\n  return { name: mapping.name, type: type, mapping: mapping, error: 'variable name does not match input mapping' }\n}\n\nde.biancoroyal.modbus.io.core.buildOutputAddressMapping = function (registerName, mapping, offset, readingOffset, logging) {\n  const ioCore = de.biancoroyal.modbus.io.core\n  let addressStart = 0\n  let coilStart = 0\n  let addressOffset = 0\n  let bits = 0\n  let bitAddress = null\n\n  const type = mapping.name.substring(0, 1)\n  const registerType = mapping.valueAddress.substring(2, 3)\n  const addressType = mapping.valueAddress.substring(0, 3)\n\n  switch (type) {\n    case 'w': // word\n    case 'u': // unsigned integer\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 1\n      bits = 16\n      break\n    case 'i': // integer\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n\n      if (registerType === 'W') {\n        addressOffset = 1\n        bits = 16\n      } else {\n        addressOffset = 2\n        bits = 32\n      }\n      break\n    case 'r': // real\n    case 'f': // float\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 2\n      bits = 32\n      break\n    case 'd': // double\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 4\n      bits = 64\n      break\n    case 'l': // long\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 5\n      bits = 80\n      break\n    case 'b': // bit - boolean\n      if (registerType === 'X') {\n        bitAddress = mapping.valueAddress.split('%QX')[1].split('.')\n        addressStart = Math.floor(Number(bitAddress[0]) / 2)\n        coilStart = Number(bitAddress[0]) * 8 + Number(bitAddress[1])\n        addressOffset = 1\n        bits = 1\n      }\n      break\n    default:\n      if (logging) {\n        ioCore.internalDebug('unknown output type ' + type)\n      }\n      bits = 0\n  }\n\n  if (bits) {\n    const addressStartIO = addressStart - (Number(offset) || 0)\n\n    return {\n      register: registerName,\n      name: mapping.name,\n      addressStart: addressStart,\n      addressOffset: addressOffset,\n      addressOffsetIO: Number(offset) || 0,\n      addressStartIO: addressStartIO,\n      registerAddress: addressStartIO - Number(readingOffset),\n      coilStart: coilStart,\n      bitAddress: bitAddress,\n      Bit: (bitAddress) ? (Number(bitAddress[0]) * 8) + Number(bitAddress[1]) : 0,\n      bits: bits,\n      dataType: ioCore.getDataTypeFromFirstCharType(type),\n      type: 'output'\n    }\n  }\n\n  return { name: mapping.name, type: type, mapping: mapping, error: 'variable name does not match output mapping' }\n}\n\nde.biancoroyal.modbus.io.core.insertValues = function (valueNames, register, logging) {\n  const ioCore = de.biancoroyal.modbus.io.core\n\n  let index = 0\n  for (index in valueNames) {\n    const item = valueNames[index]\n\n    if (!item || !Object.prototype.hasOwnProperty.call(item, 'registerAddress') || item.registerAddress < 0) {\n      if (logging) {\n        ioCore.internalDebug('Item Not Valid To Insert Value ' + JSON.stringify(item))\n      }\n      continue\n    }\n\n    if (de.biancoroyal.modbus.io.core.isRegisterSizeWrong(register, item.registerAddress, Number(item.bits))) {\n      if (logging) {\n        ioCore.internalDebug('Insert Value Register Reached At Address-Start-IO:' + item.registerAddress + ' Bits:' + Number(item.bits))\n      }\n      break\n    }\n\n    switch (Number(item.bits)) {\n      case 1:\n        item.value = !!((register[item.registerAddress] & Math.pow(item.bitAddress[1], 2)))\n        break\n      case 16:\n        item.value = register[item.registerAddress]\n        break\n      case 32:\n        item.value = register[item.registerAddress + 1] << 16 |\n          register[item.registerAddress]\n        break\n      case 64:\n        item.value = register[item.registerAddress + 3] << 48 |\n          register[item.registerAddress + 2] << 32 |\n          register[item.registerAddress + 1] << 16 |\n          register[item.registerAddress]\n        break\n      case 80:\n        item.value = register[item.registerAddress + 4] << 64 |\n          register[item.registerAddress + 3] << 48 |\n          register[item.registerAddress + 2] << 32 |\n          register[item.registerAddress + 1] << 16 |\n          register[item.registerAddress]\n        break\n      default:\n        item.value = null\n        break\n    }\n  }\n\n  return valueNames\n}\n\nde.biancoroyal.modbus.io.core.getValueFromBufferByDataType = function (item, bufferOffset, responseBuffer, logging) {\n  const ioCore = de.biancoroyal.modbus.io.core\n  const registerLength = responseBuffer.length / 2\n\n  if (bufferOffset < 0 || bufferOffset > responseBuffer.length) {\n    if (logging) {\n      ioCore.internalDebug('Wrong Buffer Access Parameter Type:' + item.dataType + ' Register-Length: ' + registerLength +\n        ' Buffer-Length:' + responseBuffer.length + ' Address-Buffer-Offset:' + bufferOffset)\n      ioCore.internalDebug(JSON.stringify(item))\n    }\n    return item\n  }\n\n  if (logging) {\n    ioCore.internalDebug('Get Value From Buffer By Data Type:' + item.dataType + ' Register:' + item.registerAddress + ' Bits:' + Number(item.bits))\n  }\n\n  switch (item.dataType) {\n    case 'Boolean':\n      item.value = !!(responseBuffer.readUInt16BE(bufferOffset) & Math.pow(item.bitAddress[1], 2))\n      break\n    case 'Word':\n      switch (item.bits) {\n        case '8':\n          item.value = responseBuffer.readInt8(bufferOffset)\n          break\n        default:\n          item.value = responseBuffer.readInt16BE(bufferOffset) // DWord\n          item.convertedValue = false\n      }\n      break\n    case 'Integer':\n      switch (item.bits) {\n        case '8':\n          item.value = responseBuffer.readInt8(bufferOffset)\n          break\n        case '32':\n          item.value = responseBuffer.readInt32BE(bufferOffset)\n          break\n        case '64':\n          item.value = responseBuffer.readIntBE(bufferOffset, 8)\n          break\n        default:\n          item.value = responseBuffer.readInt16BE(bufferOffset)\n      }\n      break\n    case 'Real':\n    case 'Float':\n      item.value = responseBuffer.readFloatBE(bufferOffset, 4)\n      break\n    case 'Double':\n      item.value = responseBuffer.readDoubleBE(bufferOffset, 8)\n      break\n    case 'Long':\n      item.value = responseBuffer.readDoubleBE(bufferOffset, 10)\n      break\n    default:\n      switch (item.bits) {\n        case '8':\n          item.value = responseBuffer.readUInt8(bufferOffset)\n          break\n        case '32':\n          item.value = responseBuffer.readUInt32BE(bufferOffset)\n          break\n        case '64':\n          item.value = responseBuffer.readUIntBE(bufferOffset, 8)\n          break\n        default:\n          item.value = responseBuffer.readUInt16BE(bufferOffset)\n          item.convertedValue = false\n      }\n      break\n  }\n\n  return item\n}\n\nde.biancoroyal.modbus.io.core.convertValuesByType = function (valueNames, register, responseBuffer, logging) {\n  const ioCore = de.biancoroyal.modbus.io.core\n  let bufferOffset = 0\n  const sixteenBitBufferLength = 2\n\n  let index = 0\n  for (index in valueNames) {\n    let item = valueNames[index]\n\n    if (!item || !Object.prototype.hasOwnProperty.call(item, 'dataType') || !Object.prototype.hasOwnProperty.call(item, 'registerAddress') || item.registerAddress < 0) {\n      if (logging) {\n        ioCore.internalDebug('Item Not Valid To Convert ' + JSON.stringify(item))\n      }\n      continue\n    }\n\n    if (de.biancoroyal.modbus.io.core.isRegisterSizeWrong(register, item.registerAddress, Number(item.bits))) {\n      if (logging) {\n        ioCore.internalDebug('Insert Value Register Reached At Address-Start-IO:' + item.registerAddress + ' Bits:' + Number(item.bits))\n      }\n      break\n    }\n\n    if (responseBuffer.buffer instanceof Buffer) {\n      bufferOffset = Number(item.registerAddress) * sixteenBitBufferLength\n      try {\n        item = ioCore.getValueFromBufferByDataType(item, bufferOffset, responseBuffer.buffer, logging)\n      } catch (err) {\n        ioCore.internalDebug(err.message)\n      }\n    } else {\n      if (logging) {\n        ioCore.internalDebug('Response Buffer Is Not A Buffer')\n      }\n      break\n    }\n  }\n\n  return valueNames\n}\n\nde.biancoroyal.modbus.io.core.filterValueNames = function (node, valueNames, fc, adr, quantity) {\n  if (!valueNames.length || !valueNames.filter) {\n    return valueNames\n  }\n\n  const ioCore = de.biancoroyal.modbus.io.core\n  let functionType = 'input'\n\n  if (fc === 2 || fc === 4) {\n    functionType = 'output'\n  }\n\n  const startRegister = adr\n  const endRegister = Number(adr) + Number(quantity) - 1\n\n  if (node.logIOActivities) {\n    ioCore.internalDebug('adr:' + adr + ' quantity:' + quantity + ' startRegister:' + startRegister + ' endRegister:' + endRegister + ' functionType:' + functionType)\n  }\n\n  return valueNames.filter((valueName) => {\n    return (valueName.registerAddress >= 0 &&\n      valueName.addressStartIO >= startRegister &&\n      valueName.addressStartIO <= endRegister &&\n      valueName.type === functionType)\n  })\n}\n\nde.biancoroyal.modbus.io.core.isRegisterSizeWrong = function (register, start, bits) {\n  const sizeDivisor = Number(bits) || 16\n  const startRegister = Number(start)\n  let endRegister = startRegister\n\n  if (sizeDivisor > 16) {\n    endRegister = startRegister + (sizeDivisor / 16) - 1\n  }\n\n  return (startRegister < 0 || register.length < startRegister || endRegister > register.length)\n}\n\nde.biancoroyal.modbus.io.core.buildMessageWithIO = function (node, values, response, msg) {\n  const origMsg = this.core.getOriginalMessage(node.bufferMessageList, msg)\n  origMsg.payload = values\n  origMsg.topic = msg.topic\n  origMsg.responseBuffer = response\n  origMsg.input = msg\n\n  const rawMsg = Object.assign({}, origMsg)\n  rawMsg.payload = response\n  rawMsg.values = values\n  delete rawMsg.responseBuffer\n\n  if (node.useIOFile && node.ioFile.lastUpdatedAt) {\n    const allValueNames = this.nameValuesFromIOFile(node, msg, values, response, parseInt(msg.payload.address) || 0)\n    const valueNames = this.filterValueNames(node, allValueNames, parseInt(msg.payload.fc) || 3,\n      parseInt(msg.payload.address) || 0,\n      parseInt(msg.payload.quantity) || 1,\n      node.logIOActivities)\n\n    if (node.useIOForPayload) {\n      origMsg.payload = valueNames\n      origMsg.values = values\n    } else {\n      origMsg.payload = values\n      origMsg.valueNames = valueNames\n    }\n\n    rawMsg.valueNames = valueNames\n    return [origMsg, rawMsg]\n  } else {\n    return [origMsg, rawMsg]\n  }\n}\n\nmodule.exports = de.biancoroyal.modbus.io.core\n"]}