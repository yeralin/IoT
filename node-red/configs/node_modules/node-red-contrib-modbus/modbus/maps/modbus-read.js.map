{"version":3,"sources":["modbus-read.js"],"names":["module","exports","RED","require","install","mbCore","mbIOCore","nodes","registerType","createNode","this","config","name","topic","unitid","dataType","adr","ModbusRead","quantity","rate","delayOnStart","parseInt","startDelayTime","rateUnit","showStatusActivities","showErrors","useIOFile","connection","getNode","ioFile","logIOActivities","node","delayTimerID","timerID","timeoutOccurred","INPUT_TIMEOUT_MILLISECONDS","modbusClient","server","payload","statusValue","values","statusOptions","mbBasics","setNodeStatusProperties","setNodeStatusWithTimeTo","status","fill","shape","get_timeUnit_name","registerForModbus","initModbusClientEvents","setNodeStatusTo","onModbusConnect","setTimeout","startIntervalReading","clearTimeout","setInterval","modbusPollingRead","calc_rateByUnit","onModbusActive","failureMsg","reconnectOnTimeout","onModbusError","clearInterval","warn","onModbusClose","onModbusBroken","reconnectTimeout","onModbusInit","on","client","fc","messageId","getObjectId","from","address","msg","onModbusReadDone","onModbusReadError","resp","setModbusError","response","lastUpdatedAt","internalDebug","done","allValueNames","nameValuesFromIOFile","valueNames","filterValueNames","functionCodeModbusRead","origMsg","deregisterForModbus","responseBuffer","input","useIOForPayload","sendMessage","data","err","internalDebugLog","message","httpAdmin","getTimeInfo","auth","needsPermission","req","res","sendStatus","error","_","toString"],"mappings":"aAgBAA,OAAOC,QAAU,SAAUC,GAEzBC,QAAQ,sBAAsBC,UAFhCJ,IAAOC,EAAUE,QAAUD,mBACzBG,EAAAF,QAAA,sBAIMG,EAAWH,QAAQ,yBAHzBA,EAAQA,QAAsBC,QAAtBD,CAAR,sBA0OGD,EAAAK,MAAAC,aAAA,cAzOH,SAAiBL,GAMfD,EAAIK,MAAME,WAAWC,KAAMC,GAE3BD,KAAKE,KAAOD,EAAOC,KANrBF,KAAMJ,MAAWH,EAAOU,MAQtBH,KAAKI,OAASH,EAAOG,OAErBJ,KAAKK,SAAWJ,EAAOI,SAPzBL,KAAAM,IAASC,EAAYN,IACnBT,KAAIK,SAAME,EAAWS,UAArB,EAGAR,KAAKG,KAALF,EAAmBQ,KACnBT,KAAKI,SAASH,EAAOG,SAGrBJ,KAAKM,aAAaA,EAAlBI,aACAV,KAAKQ,eAAiBG,SAANV,EAAhBW,iBAAA,GAGAZ,KAAKa,qBAAkBA,EAAvBC,qBAEAd,KAAKU,WAALT,EAAoBA,WACpBD,KAAKY,WAAAA,KAGLZ,KAAKe,UAALd,EAAwBe,UACxBhB,KAAKiB,OAAAA,EAAapB,MAAlBqB,QAAAjB,EAAAkB,QAEAnB,KAAKgB,gBAAkBf,EAACe,gBACxBhB,KAAKmB,gBAASlB,EAAUiB,gBAExB,IAAKE,EAAAA,KAECC,EAAN,KACIC,EAAAA,KACAC,GAAJ,EACAF,EAAIG,2BAAJ,IACAH,EAAKI,gBAAAA,UAA6BJ,GAGlC,IAAMK,EAAelC,EAAIK,MAAMqB,QAAQjB,EAAO0B,QAsKtCC,SAAAA,EADFC,GAEEC,GAFF,YAEEA,IAFFN,EAEEM,CAKP,IAAAC,EAAAC,EAAAC,wBAAAJ,EAAAR,EAAAP,uBAEiCe,IAAlCA,EAASK,OAAAA,WAAsC,YAA/CL,GACEL,GAAoB,EAClBH,EAAAc,OAAA,CACDC,KAAAL,EAAAK,KAQGC,MAAON,EAAcM,MANnBN,KAAAA,EAAgBC,OAYlBK,MAAON,EAAAA,KAAcM,IAFXL,EAAAM,kBAAAjB,EAAAR,UAAA,SAPZW,EAAAA,OAAAA,CACAH,KAAKc,EAAOC,KACVA,MAAML,EAAcK,MACpBC,KAAKN,EAAeI,UAxLrBT,IAEJA,EAAAa,kBAAAlB,GAEDW,EAASQ,uBAAuBnB,EAAMK,GAAtCM,EAAAA,aAASQ,WAGPR,EAASS,gBAAgB,aAAcpB,IACxCA,EAFDqB,gBAAA,WAKMrB,EAAKX,aACPY,GAFCoB,GAGCpB,aAAYA,GACPqB,WAAAtB,EAAAuB,qBAAAvB,EAAAI,2BAAAJ,EAAAT,kBAGNU,GANHuB,aAOOvB,GAEHuB,EAAAA,wBAEFxB,EAAKuB,cAGPV,EAAAA,qBAAwB,WAKtBX,EApBJA,GAoBcuB,YAAYzB,EAAK0B,kBAAmBf,EAASgB,gBAAgB3B,EAAKZ,KAAMY,EAAKR,YACxFQ,EAAA4B,eAAA,WAHHf,EAAA,WAOEA,EAAAA,cAAAA,SAAwBgB,GAD1BlB,EAAAS,gBAAA,UAAApB,GAMMK,EAAayB,qBAFdC,GACHpB,cAASS,GACTlB,EAAIG,MAEA2B,EAAAA,YACDhC,EAAAiC,KAAAJ,IAQL7B,EAAKkC,cAAgB,WALnBvB,EAASjB,gBAAY,SAAAM,GACnBA,GACDgC,cAAA9B,GAQDA,EAAU,MAGZF,EAAKmC,eAAiB,WANhBjC,EAAS4B,qBACXE,EAAAA,gBAAuB,sBAAA3B,EAAA+B,iBAAA,SAAApC,GACxBE,GAQG8B,cAAc9B,GAZpBA,EAAA,OAUIS,EAASS,GAAAA,SAAAA,EAAgBiB,cAS7BhC,EAAaiC,GAAG,cAAetC,EAAKqB,iBARhChB,EAAIH,GAAJ,WAAaF,EAAA4B,gBACXI,EAAAA,GAAAA,UAAahC,EAAU+B,eACxB1B,EAAAiC,GAAA,WAAAtC,EAAAmC,gBAUL9B,EAAaiC,GAAG,WAAYtC,EAAKkC,eAR9BlC,EAAA0B,kBAAA,WAPH,GAAArB,EAAAkC,OAAA,CAaAlC,IAAAA,EAAaiC,CACbjC,MAAAA,EAAgBvB,OAAA,UAChBuB,KAAAA,EAAAxB,KAWI0B,QAAS,CATRmB,OAAAA,EAAAA,OACCc,GAACnC,EAAAA,uBAAqBL,EAAAhB,UACxB6B,QAAAA,EAAAA,IACA1B,SAAAa,EAAAb,SACDsD,UAAAnE,EAAAoE,gBAICC,EAAM3C,sBACNO,EAAS,WAGPqC,EAAS5C,KAAKf,aAHP4D,EAAA7C,EAAA8C,iBAAA9C,EAAA+C,wBAPTlC,EAAwB,YAOfb,EAAA8C,iBAAA,SAAAE,EAAAH,GAHX7C,EAAAP,sBAqBEoB,EAAwB,gBAW1BF,SAASsC,EAATC,EAA8B7C,GALhC,GAAAL,EAAAL,WAAAK,EAAAF,OAAAqD,cAAA,CAmBQnD,EAAKD,iBAXRuC,EAALc,cAA2BC,YAAMrD,EAAAf,IAAA,kBAAAe,EAAAb,UAG9B,IAAAmE,EAAA/E,EAAAgF,qBAAAvD,EAAA6C,EAAApC,EAAAyC,EAAAlD,EAAAf,KAaOuE,EAAajF,EAASkF,iBAAiBzD,EAAMsD,EAAehF,EAAOoF,uBAAuB1D,EAAKhB,UAAWgB,EAAKf,IAAKe,EAAKb,UAXzHwE,EAACvC,CACTf,MAAAA,EAAauD,MANfC,eAAAX,EAqBMY,MAAOjB,GAVL7C,EAAKD,iBACPxB,EAAQgC,QAAC6C,EACVO,EAAAlD,OAAAA,IAEDkD,EAAML,QAAgB/E,EACtBoF,EAAMH,WAAajF,GAIjBsF,EAAAA,KAAAA,CACAC,EAHF,CAiBIvD,QAAS2C,EAXTlD,OAAK+D,EACPJ,MAAQpD,EACRoD,WAAAH,UAGAG,EAAAA,KAAQH,CACT,CAaGjD,QAASE,EAXToD,eAEFX,EACE3C,MAAS2C,GAETY,CACAN,QAAUN,EANdzC,OAAAA,EAtBFqD,MA8BOjB,KA7DNmB,CAAAhB,EAAAiB,KAAAjB,EAAAH,IAGF7C,EAvBD+C,kBAAA,SAAAmB,EAAArB,GAkCEsB,EAAiBD,EAAIE,SATlBtB,EAAAA,YACH9C,EAAIA,MAAKP,EAAAA,GAERkB,EAAAsC,eAAAjD,EAAAK,EAAA6D,EAAArB,IAGF7C,EANDsC,GAAA,QAAA,SAAAe,GAiBMnD,GATF8B,cAACe,GAYH7C,EAAU,KAVVS,EAASjB,gBAAY,SAAAM,GACnBA,EAAWkE,oBAAXlE,EAAAqD,QAoFJlF,EAAAkG,UAASC,KAAAA,0BAAenG,EAAAoG,KAAAC,gBAAA,uBAAA,SAAAC,EAAAC,GACtB,IAAA1E,EAAO7B,EAAQ6B,MAAKZ,QAAOqF,EAAM9D,OAAAA,IAEpC,GAAAX,EAQG,IANAxB,EAAMC,oBAEN4F,EAAAA,WAAe,KACXrE,MAAO7B,GAOTuG,EAAIC,WAAW,KALf3E,EAAJ4E,MAAUzG,EAAA0G,EAAA,sBAAA,CAAAD,MAAAV,EAAAY,mBAGNJ,EAAAA,WAAIC","file":"../modbus-read.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019 Klaus Landsdorf (https://bianco-royal.com/)\n Copyright 2016 - Jason D. Harper, Argonne National Laboratory\n Copyright 2015,2016 - Mika Karaila, Valmet Automation Inc.\n Copyright 2013, 2016 IBM Corp. (node-red)\n All rights reserved.\n node-red-contrib-modbus\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n **/\n/**\n * Modbus Read node.\n * @module NodeRedModbusRead\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const mbCore = require('./core/modbus-core')\n  const mbIOCore = require('./core/modbus-io-core')\n  const internalDebugLog = require('debug')('contribModbus:read')\n\n  function ModbusRead (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.topic = config.topic\n    this.unitid = config.unitid\n\n    this.dataType = config.dataType\n    this.adr = config.adr\n    this.quantity = config.quantity || 1\n\n    this.rate = config.rate\n    this.rateUnit = config.rateUnit\n\n    this.delayOnStart = config.delayOnStart\n    this.startDelayTime = parseInt(config.startDelayTime) || 10\n\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n    this.connection = null\n\n    this.useIOFile = config.useIOFile\n    this.ioFile = RED.nodes.getNode(config.ioFile)\n    this.useIOForPayload = config.useIOForPayload\n    this.logIOActivities = config.logIOActivities\n\n    const node = this\n    let delayTimerID = null\n    let timerID = null\n    let timeoutOccurred = false\n    node.INPUT_TIMEOUT_MILLISECONDS = 1000\n    mbBasics.setNodeStatusTo('waiting', node)\n\n    const modbusClient = RED.nodes.getNode(config.server)\n    if (!modbusClient) {\n      return\n    }\n    modbusClient.registerForModbus(node)\n    mbBasics.initModbusClientEvents(node, modbusClient)\n\n    node.onModbusInit = function () {\n      mbBasics.setNodeStatusTo('initialize', node)\n    }\n\n    node.onModbusConnect = function () {\n      if (node.delayOnStart) {\n        if (!delayTimerID) {\n          delayTimerID = setTimeout(node.startIntervalReading, node.INPUT_TIMEOUT_MILLISECONDS * node.startDelayTime)\n        } else {\n          clearTimeout(delayTimerID)\n          delayTimerID = setTimeout(node.startIntervalReading, node.INPUT_TIMEOUT_MILLISECONDS * node.startDelayTime)\n        }\n      } else {\n        if (delayTimerID) {\n          clearTimeout(delayTimerID)\n        }\n        node.startIntervalReading()\n      }\n\n      setNodeStatusWithTimeTo('connected')\n    }\n\n    node.startIntervalReading = function () {\n      if (!timerID) {\n        timerID = setInterval(node.modbusPollingRead, mbBasics.calc_rateByUnit(node.rate, node.rateUnit))\n      }\n    }\n\n    node.onModbusActive = function () {\n      setNodeStatusWithTimeTo('active')\n    }\n\n    node.onModbusError = function (failureMsg) {\n      mbBasics.setNodeStatusTo('failure', node)\n      if (modbusClient.reconnectOnTimeout) {\n        if (timerID) {\n          clearInterval(timerID) // clear Timer from events\n        }\n        timerID = null\n      }\n      if (node.showErrors) {\n        node.warn(failureMsg)\n      }\n    }\n\n    node.onModbusClose = function () {\n      mbBasics.setNodeStatusTo('closed', node)\n      if (timerID) {\n        clearInterval(timerID) // clear Timer from events\n      }\n      timerID = null\n    }\n\n    node.onModbusBroken = function () {\n      if (modbusClient.reconnectOnTimeout) {\n        mbBasics.setNodeStatusTo('reconnecting after ' + modbusClient.reconnectTimeout + ' msec.', node)\n        if (timerID) {\n          clearInterval(timerID) // clear Timer from events\n        }\n        timerID = null\n      }\n    }\n\n    modbusClient.on('mbinit', node.onModbusInit)\n    modbusClient.on('mbconnected', node.onModbusConnect)\n    modbusClient.on('mbactive', node.onModbusActive)\n    modbusClient.on('mberror', node.onModbusError)\n    modbusClient.on('mbbroken', node.onModbusBroken)\n    modbusClient.on('mbclosed', node.onModbusClose)\n\n    node.modbusPollingRead = function () {\n      if (!modbusClient.client) {\n        setNodeStatusWithTimeTo('waiting')\n        return\n      }\n\n      const msg = {\n        topic: node.topic || 'polling',\n        from: node.name,\n        payload: {\n          unitid: node.unitid,\n          fc: mbCore.functionCodeModbusRead(node.dataType),\n          address: node.adr,\n          quantity: node.quantity,\n          messageId: mbCore.getObjectId()\n        }\n      }\n\n      if (node.showStatusActivities) {\n        setNodeStatusWithTimeTo('polling')\n      }\n\n      modbusClient.emit('readModbus', msg, node.onModbusReadDone, node.onModbusReadError)\n    }\n\n    node.onModbusReadDone = function (resp, msg) {\n      if (node.showStatusActivities) {\n        setNodeStatusWithTimeTo('reading done')\n      }\n\n      sendMessage(resp.data, resp, msg)\n    }\n\n    node.onModbusReadError = function (err, msg) {\n      internalDebugLog(err.message)\n      if (node.showErrors) {\n        node.error(err, msg)\n      }\n      mbBasics.setModbusError(node, modbusClient, err, msg)\n    }\n\n    node.on('close', function (done) {\n      if (timerID) {\n        clearInterval(timerID)\n      }\n      timerID = null\n      mbBasics.setNodeStatusTo('closed', node)\n      modbusClient.deregisterForModbus(node, done)\n    })\n\n    function sendMessage (values, response, msg) {\n      if (node.useIOFile && node.ioFile.lastUpdatedAt) {\n        if (node.logIOActivities) {\n          mbIOCore.internalDebug('node.adr:' + node.adr + ' node.quantity:' + node.quantity)\n        }\n\n        const allValueNames = mbIOCore.nameValuesFromIOFile(node, msg, values, response, node.adr)\n        const valueNames = mbIOCore.filterValueNames(node, allValueNames, mbCore.functionCodeModbusRead(node.dataType), node.adr, node.quantity)\n\n        const origMsg = {\n          topic: msg.topic,\n          responseBuffer: response,\n          input: msg\n        }\n\n        if (node.useIOForPayload) {\n          origMsg.payload = valueNames\n          origMsg.values = values\n        } else {\n          origMsg.payload = values\n          origMsg.valueNames = valueNames\n        }\n\n        node.send([\n          origMsg,\n          {\n            payload: response,\n            values: values,\n            input: msg,\n            valueNames: valueNames\n          }])\n      } else {\n        node.send([\n          {\n            payload: values,\n            responseBuffer: response,\n            input: msg\n          },\n          {\n            payload: response,\n            values: values,\n            input: msg\n          }\n        ])\n      }\n    }\n\n    function setNodeStatusWithTimeTo (statusValue) {\n      if (statusValue === 'polling' && timeoutOccurred) {\n        return\n      }\n\n      const statusOptions = mbBasics.setNodeStatusProperties(statusValue, node.showStatusActivities)\n\n      if (statusValue.search('active') !== -1 || statusValue === 'polling') {\n        timeoutOccurred = false\n        node.status({\n          fill: statusOptions.fill,\n          shape: statusOptions.shape,\n          text: statusOptions.status + getTimeInfo()\n        })\n      } else {\n        node.status({\n          fill: statusOptions.fill,\n          shape: statusOptions.shape,\n          text: statusOptions.status\n        })\n      }\n    }\n\n    function getTimeInfo () {\n      return ' ( ' + node.rate + ' ' + mbBasics.get_timeUnit_name(node.rateUnit) + ' ) '\n    }\n  }\n\n  RED.nodes.registerType('modbus-read', ModbusRead)\n\n  RED.httpAdmin.post('/modbus/read/inject/:id', RED.auth.needsPermission('modbus.inject.write'), function (req, res) {\n    const node = RED.nodes.getNode(req.params.id)\n\n    if (node) {\n      try {\n        node.modbusPollingRead()\n        res.sendStatus(200)\n      } catch (err) {\n        res.sendStatus(500)\n        node.error(RED._('modbusinject.failed', { error: err.toString() }))\n      }\n    } else {\n      res.sendStatus(404)\n    }\n  })\n}\n"]}