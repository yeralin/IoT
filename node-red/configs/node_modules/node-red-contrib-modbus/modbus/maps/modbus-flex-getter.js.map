{"version":3,"sources":["modbus-flex-getter.js"],"names":["module","exports","RED","require","install","mbCore","mbIOCore","nodes","registerType","config","createNode","this","name","showStatusActivities","showErrors","internalDebugLog","useIOFile","ModbusFlexGetter","getNode","ioFile","useIOForPayload","connection","node","mbBasics","logIOActivities","server","modbusClient","initModbusClientEvents","onModbusReadDone","resp","msg","setNodeStatusTo","send","buildMessageWithIO","data","err","message","setModbusError","getOriginalMessage","bufferMessageList","on","payload","JSON","parse","fc","parseInt","unitid","address","quantity","isInteger","Number","error","messageId","getObjectId","set","topic","id","value","_msgid","emit","onModbusReadError","actualServiceState","done","clear","deregisterForModbus"],"mappings":"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","file":"../modbus-flex-getter.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019 Klaus Landsdorf (https://bianco-royal.com/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n/**\n * Modbus flexible Getter node.\n * @module NodeRedModbusFlexGetter\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const mbCore = require('./core/modbus-core')\n  const mbIOCore = require('./core/modbus-io-core')\n  const internalDebugLog = require('debug')('contribModbus:flex:getter')\n\n  function ModbusFlexGetter (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n    this.connection = null\n\n    this.useIOFile = config.useIOFile\n    this.ioFile = RED.nodes.getNode(config.ioFile)\n    this.useIOForPayload = config.useIOForPayload\n    this.logIOActivities = config.logIOActivities\n\n    const node = this\n    node.bufferMessageList = new Map()\n    mbBasics.setNodeStatusTo('waiting', node)\n\n    const modbusClient = RED.nodes.getNode(config.server)\n    if (!modbusClient) {\n      return\n    }\n    modbusClient.registerForModbus(node)\n    mbBasics.initModbusClientEvents(node, modbusClient)\n\n    node.onModbusReadDone = function (resp, msg) {\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo('reading done', node)\n      }\n\n      node.send(mbIOCore.buildMessageWithIO(node, resp.data, resp, msg))\n    }\n\n    node.onModbusReadError = function (err, msg) {\n      internalDebugLog(err.message)\n      if (node.showErrors) {\n        node.error(err, msg)\n      }\n      mbBasics.setModbusError(node, modbusClient, err, mbCore.getOriginalMessage(node.bufferMessageList, msg))\n    }\n\n    node.on('input', function (msg) {\n      if (mbBasics.invalidPayloadIn(msg)) {\n        return\n      }\n\n      if (!modbusClient.client) {\n        return\n      }\n\n      try {\n        if (typeof msg.payload === 'string') {\n          msg.payload = JSON.parse(msg.payload)\n        }\n\n        msg.payload.fc = parseInt(msg.payload.fc) || 3\n        msg.payload.unitid = parseInt(msg.payload.unitid)\n        msg.payload.address = parseInt(msg.payload.address) || 0\n        msg.payload.quantity = parseInt(msg.payload.quantity) || 1\n\n        if (!(Number.isInteger(msg.payload.fc) &&\n              msg.payload.fc >= 1 &&\n              msg.payload.fc <= 4)) {\n          node.error('FC Not Valid', msg)\n          return\n        }\n\n        if (!(Number.isInteger(msg.payload.address) &&\n              msg.payload.address >= 0 &&\n              msg.payload.address <= 65535)) {\n          node.error('Address Not Valid', msg)\n          return\n        }\n\n        if (!(Number.isInteger(msg.payload.quantity) &&\n              msg.payload.quantity >= 1 &&\n              msg.payload.quantity <= 65535)) {\n          node.error('Quantity Not Valid', msg)\n          return\n        }\n\n        msg.messageId = mbCore.getObjectId()\n        node.bufferMessageList.set(msg.messageId, msg)\n\n        msg = {\n          topic: msg.topic || node.id,\n          payload: {\n            value: msg.payload.value || msg.value,\n            unitid: msg.payload.unitid,\n            fc: msg.payload.fc,\n            address: msg.payload.address,\n            quantity: msg.payload.quantity,\n            messageId: msg.messageId\n          },\n          _msgid: msg._msgid\n        }\n\n        modbusClient.emit('readModbus', msg, node.onModbusReadDone, node.onModbusReadError)\n      } catch (err) {\n        internalDebugLog(err.message)\n        if (node.showErrors) {\n          node.error(err, msg)\n        }\n      }\n\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo(modbusClient.actualServiceState, node)\n      }\n    })\n\n    node.on('close', function (done) {\n      mbBasics.setNodeStatusTo('closed', node)\n      node.bufferMessageList.clear()\n      modbusClient.deregisterForModbus(node, done)\n    })\n  }\n\n  RED.nodes.registerType('modbus-flex-getter', ModbusFlexGetter)\n}\n"]}