{"version":3,"sources":["core/modbus-client-core.js"],"names":["require","install","de","biancoroyal","modbus","core","client","internalDebug","internalDebugFSM","modbusSerialDebug","XStateFSM","stateLogEnabled","networkErrors","this","createMachine","initial","new","INIT","on","STOP","FAILURE","CLOSE","ACTIVATE","init","states","CONNECT","activated","broken","READ","queueing","OPENSERIAL","QUEUE","BREAK","failed","stopped","NEW","startStateService","toggleMachine","interpret","start","checkUnitId","unitid","clientType","readModbus","node","msg","cb","cberr","EMPTY","send","setUnitIdFromPayload","empty","setTimeout","clientTimeout","JSON","stringify","payload","queueUnitId","timeout","getTimeout","reading","actualServiceState","value","parseInt","fc","writing","readCoils","address","quantity","then","resp","activateSending","err","closed","modbusErrorHandling","readDiscreteInputs","readHoldingRegisters","Error","e","message","writeModbus","queueLog","info","state","length","writeCoils","readInputRegisters","writeRegisters","writeRegister","setNewNodeSettings","tcpHost","tcpType","tcpPort","serialPort","serialBaudrate","serialDatabits","serialStopbits","serialParity","serialType","writeCoil","serialConnectionDelay","connectorType","unitId","unit_id","commandDelay","reconnectTimeout","messagesAllowedStates","module","exports"],"mappings":"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","file":"../../core/modbus-client-core.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019 Klaus Landsdorf (https://bianco-royal.com/)\n All rights reserved.\n node-red-contrib-modbus\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n'use strict'\nrequire('source-map-support').install()\n\nvar de = de || { biancoroyal: { modbus: { core: { client: {} } } } } // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.core.client.internalDebug = de.biancoroyal.modbus.core.client.internalDebug || require('debug')('contribModbus:core:client') // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.core.client.internalDebugFSM = de.biancoroyal.modbus.core.client.internalDebugFSM || require('debug')('contribModbus:core:client:fsm') // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.core.client.modbusSerialDebug = de.biancoroyal.modbus.core.client.modbusSerialDebug || require('debug')('modbus-serial') // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.core.client.XStateFSM = de.biancoroyal.modbus.core.client.XStateFSM || require('@xstate/fsm') // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.core.client.stateLogEnabled = de.biancoroyal.modbus.core.client.stateLogEnabled || false // eslint-disable-line no-use-before-define\n\nde.biancoroyal.modbus.core.client.networkErrors = ['ESOCKETTIMEDOUT', 'ETIMEDOUT', 'ECONNRESET', 'ENETRESET',\n  'ECONNABORTED', 'ECONNREFUSED', 'ENETUNREACH', 'ENOTCONN',\n  'ESHUTDOWN', 'EHOSTDOWN', 'ENETDOWN', 'EWOULDBLOCK', 'EAGAIN', 'EHOSTUNREACH']\n\nde.biancoroyal.modbus.core.client.createStateMachineService = function () {\n  this.stateLogEnabled = false\n\n  return this.XStateFSM.createMachine({\n    id: 'modbus',\n    initial: 'new',\n    states: {\n      new: {\n        on: { INIT: 'init', STOP: 'stopped' }\n      },\n      broken: {\n        on: { INIT: 'init', STOP: 'stopped', FAILURE: 'failed', CLOSE: 'closed', ACTIVATE: 'activated' }\n      },\n      init: {\n        on: { OPENSERIAL: 'opened', CONNECT: 'connected', FAILURE: 'failed' }\n      },\n      opened: {\n        on: { CONNECT: 'connected', FAILURE: 'failed', CLOSE: 'closed' }\n      },\n      connected: {\n        on: { CLOSE: 'closed', ACTIVATE: 'activated', FAILURE: 'failed' }\n      },\n      activated: {\n        on: {\n          CLOSE: 'closed',\n          READ: 'reading',\n          WRITE: 'writing',\n          QUEUE: 'queueing',\n          FAILURE: 'failed'\n        }\n      },\n      queueing: {\n        on: {\n          ACTIVATE: 'activated',\n          READ: 'reading',\n          WRITE: 'writing',\n          EMPTY: 'empty',\n          FAILURE: 'failed',\n          CLOSE: 'closed'\n        }\n      },\n      empty: { on: { QUEUE: 'queueing', FAILURE: 'failed', CLOSE: 'closed' } },\n      reading: { on: { ACTIVATE: 'activated', FAILURE: 'failed' } },\n      writing: { on: { ACTIVATE: 'activated', FAILURE: 'failed' } },\n      closed: { on: { FAILURE: 'failed', BREAK: 'broken', CONNECT: 'connected' } },\n      failed: { on: { CLOSE: 'closed', BREAK: 'broken', STOP: 'stopped' } },\n      stopped: { on: { NEW: 'new', STOP: 'stopped' } }\n    }\n  })\n}\n\nde.biancoroyal.modbus.core.client.startStateService = function (toggleMachine) {\n  return this.XStateFSM.interpret(toggleMachine).start()\n}\n\nde.biancoroyal.modbus.core.client.checkUnitId = function (unitid, clientType) {\n  if (clientType === 'tcp') {\n    return unitid >= 0 && unitid <= 255\n  } else {\n    return unitid >= 1 && unitid <= 247\n  }\n}\n\nde.biancoroyal.modbus.core.client.readModbus = function (node, msg, cb, cberr) {\n  if (!node.client) {\n    return\n  }\n\n  if (!node.bufferCommands) {\n    node.stateService.send('READ')\n  }\n\n  node.setUnitIdFromPayload(msg)\n  node.client.setTimeout(node.clientTimeout)\n\n  node.queueLog(JSON.stringify({\n    info: 'read msg',\n    message: msg.payload,\n    unitid: msg.queueUnitId,\n    timeout: node.client.getTimeout(),\n    state: node.actualServiceState.value\n  }))\n\n  try {\n    switch (parseInt(msg.payload.fc)) {\n      case 1: // FC: 1\n        node.client.readCoils(parseInt(msg.payload.address), parseInt(msg.payload.quantity)).then(function (resp) {\n          node.activateSending(msg)\n          cb(resp, msg)\n        }).catch(function (err) {\n          node.activateSending(msg)\n          cberr(err, msg)\n          node.modbusErrorHandling(err)\n        })\n        break\n      case 2: // FC: 2\n        node.client.readDiscreteInputs(parseInt(msg.payload.address), parseInt(msg.payload.quantity)).then(function (resp) {\n          node.activateSending(msg)\n          cb(resp, msg)\n        }).catch(function (err) {\n          node.activateSending(msg)\n          cberr(err, msg)\n          node.modbusErrorHandling(err)\n        })\n        break\n      case 3: // FC: 3\n        node.client.readHoldingRegisters(parseInt(msg.payload.address), parseInt(msg.payload.quantity)).then(function (resp) {\n          node.activateSending(msg)\n          cb(resp, msg)\n        }).catch(function (err) {\n          node.activateSending(msg)\n          cberr(err, msg)\n          node.modbusErrorHandling(err)\n        })\n        break\n      case 4: // FC: 4\n        node.client.readInputRegisters(parseInt(msg.payload.address), parseInt(msg.payload.quantity)).then(function (resp) {\n          node.activateSending(msg)\n          cb(resp, msg)\n        }).catch(function (err) {\n          node.activateSending(msg)\n          cberr(err, msg)\n          node.modbusErrorHandling(err)\n        })\n        break\n      default:\n        node.activateSending(msg)\n        cberr(new Error('Function Code Unknown'), msg)\n        this.internalDebug('Function Code Unknown %s', msg.payload.fc)\n        break\n    }\n  } catch (e) {\n    this.internalDebug(e.message)\n    node.modbusErrorHandling(e)\n  }\n}\n\nde.biancoroyal.modbus.core.client.writeModbus = function (node, msg, cb, cberr) {\n  if (!node.client) {\n    return\n  }\n\n  if (!node.bufferCommands) {\n    node.stateService.send('WRITE')\n  }\n\n  node.setUnitIdFromPayload(msg)\n  node.client.setTimeout(node.clientTimeout)\n\n  node.queueLog(JSON.stringify({\n    info: 'write msg',\n    message: msg.payload,\n    unitid: msg.queueUnitId,\n    timeout: node.client.getTimeout(),\n    state: node.actualServiceState.value\n  }))\n\n  try {\n    switch (parseInt(msg.payload.fc)) {\n      case 15: // FC: 15\n        if (parseInt(msg.payload.value.length) !== parseInt(msg.payload.quantity)) {\n          node.activateSending(msg)\n          cberr(new Error('Quantity should be less or equal to coil payload array length: ' +\n            msg.payload.value.length + ' Addr: ' + msg.payload.address + ' Q: ' + msg.payload.quantity), msg)\n        } else {\n          node.client.writeCoils(parseInt(msg.payload.address), msg.payload.value).then(function (resp) {\n            node.activateSending(msg)\n            cb(resp, msg)\n          }).catch(function (err) {\n            node.activateSending(msg)\n            cberr(err, msg)\n            node.modbusErrorHandling(err)\n          })\n        }\n        break\n      case 5: // FC: 5\n        if (msg.payload.value) {\n          msg.payload.value = true\n        } else {\n          msg.payload.value = false\n        }\n        node.client.writeCoil(parseInt(msg.payload.address), msg.payload.value).then(function (resp) {\n          node.activateSending(msg)\n          cb(resp, msg)\n        }).catch(function (err) {\n          node.activateSending(msg)\n          cberr(err, msg)\n          node.modbusErrorHandling(err)\n        })\n        break\n      case 16: // FC: 16\n        if (parseInt(msg.payload.value.length) !== parseInt(msg.payload.quantity)) {\n          node.activateSending(msg)\n          cberr(new Error('Quantity should be less or equal to register payload array length: ' +\n            msg.payload.value.length + ' Addr: ' + msg.payload.address + ' Q: ' + msg.payload.quantity), msg)\n        } else {\n          node.client.writeRegisters(parseInt(msg.payload.address), msg.payload.value).then(function (resp) {\n            node.activateSending(msg)\n            cb(resp, msg)\n          }).catch(function (err) {\n            node.activateSending(msg)\n            cberr(err, msg)\n            node.modbusErrorHandling(err)\n          })\n        }\n        break\n      case 6: // FC: 6\n        node.client.writeRegister(parseInt(msg.payload.address), parseInt(msg.payload.value)).then(function (resp) {\n          node.activateSending(msg)\n          cb(resp, msg)\n        }).catch(function (err) {\n          node.activateSending(msg)\n          cberr(err, msg)\n          node.modbusErrorHandling(err)\n        })\n        break\n      default:\n        node.activateSending(msg)\n        cberr(new Error('Function Code Unknown'), msg)\n        this.internalDebug('Function Code Unknown %s', msg.payload.fc)\n        break\n    }\n  } catch (e) {\n    this.internalDebug(e.message)\n    node.modbusErrorHandling(e)\n  }\n}\n\nde.biancoroyal.modbus.core.client.setNewNodeSettings = function (node, msg) {\n  if (!msg) {\n    this.internalDebug('New Connection message invalid.')\n  }\n\n  switch (msg.payload.connectorType) {\n    case 'TCP':\n      node.tcpHost = msg.payload.tcpHost || node.tcpHost\n      node.tcpPort = msg.payload.tcpPort || node.tcpPort\n      node.tcpType = msg.payload.tcpType || node.tcpType\n\n      this.internalDebug('New Connection Data ' + node.tcpHost + ' ' + node.tcpPort + ' ' + node.tcpType)\n      break\n\n    case 'SERIAL':\n      if (msg.payload.serialPort) {\n        node.serialPort = msg.payload.serialPort || node.serialPort\n      }\n\n      if (msg.payload.serialBaudrate) {\n        node.serialBaudrate = parseInt(msg.payload.serialBaudrate) || node.serialBaudrate\n      }\n\n      node.serialDatabits = msg.payload.serialDatabits || node.serialDatabits\n      node.serialStopbits = msg.payload.serialStopbits || node.serialStopbits\n      node.serialParity = msg.payload.serialParity || node.serialParity\n      node.serialType = msg.payload.serialType || node.serialType\n\n      if (msg.payload.serialConnectionDelay) {\n        node.serialConnectionDelay = parseInt(msg.payload.serialConnectionDelay) || node.serialConnectionDelay\n      }\n      this.internalDebug('New Connection Data ' + node.serialPort + ' ' + node.serialBaudrate + ' ' + node.serialType)\n      break\n\n    default:\n      this.internalDebug('Unknown Dynamic Reconnect Type ' + msg.payload.connectorType)\n  }\n\n  if (msg.payload.unitId) {\n    node.unit_id = parseInt(msg.payload.unitId) || node.unit_id\n  }\n\n  if (msg.payload.commandDelay) {\n    node.commandDelay = parseInt(msg.payload.commandDelay) || node.commandDelay\n  }\n\n  if (msg.payload.clientTimeout) {\n    node.clientTimeout = parseInt(msg.payload.clientTimeout) || node.clientTimeout\n  }\n\n  if (msg.payload.reconnectTimeout) {\n    node.reconnectTimeout = parseInt(msg.payload.reconnectTimeout) || node.reconnectTimeout\n  }\n}\n\nde.biancoroyal.modbus.core.client.messagesAllowedStates = ['activated', 'queueing', 'empty']\n\nmodule.exports = de.biancoroyal.modbus.core.client\n"]}