{"version":3,"sources":["modbus-server.js"],"names":["module","exports","RED","require","install","net","internalDebugLog","nodes","registerType","config","this","name","hostname","serverPort","ModbusServer","parseInt","responseDelay","bufferFactor","delayUnit","logEnabled","coilsBufferSize","holdingBufferSize","inputBufferSize","node","showErrors","modbusServer","modbusLogLevel","settings","verbose","netServer","Server","modbus","server","TCP","logLabel","logLevel","alloc","mbBasics","calc_rateByUnit","coils","Buffer","holding","input","on","client","socket","JSON","stringify","address","remoteAddress","remotePort","setNodeStatusTo","listen","err","message","warn","msg","send","buildMessage","type","payload","discrete","done","close"],"mappings":"aAaAA,OAAOC,QAAU,SAAUC,GAEzBC,QAAQ,sBAAsBC,UAFhCJ,IAAOC,EAAUE,QAAA,YACfE,EAAAF,QAAA,OACAA,EAAQA,QAAA,mBAKFG,EAAmBH,QAAQ,QAARA,CAAiB,wBA4EvC,IAeDD,EAAIK,MAAMC,aAAa,gBAzFzB,SAAuBC,GALvBP,EAAMG,MAAMF,WAAOO,KAAnBD,GASEC,KAAKC,KAAOF,EAAOE,KANrBD,KAAMJ,WAAgBG,EAAGN,WAQvBO,KAAKE,SAAWH,EAAOG,UAAY,UANrCF,KAAAG,WAASC,SAATL,EAA+BI,YAC7BX,KAAIK,cAAiBQ,SAAMN,EAA3BO,eACAN,KAAMO,UAAYR,EAAlBS,UAGAR,KAAKS,gBAAaV,SAHG,EAGIU,EAAzBC,iBACAV,KAAKE,kBAAkBA,SAJF,EAILH,EAAmBY,mBACnCX,KAAKG,gBAAaE,SALG,EAKMN,EAAOI,iBAClCH,KAAKM,mBAAgBD,SANA,EAMSN,EAAOO,oBAGrCN,KAAKU,WAAAA,EAAkBL,WAEvB,IAAKO,EAAAA,KAGLC,EAAKC,UAAL,KAEAD,EAAMA,aAAN,KAGAA,EAAKE,gBAAL,cAAAF,GAIA,IAAIG,EAAiB,OACjBxB,EAAIyB,SAASC,UAAjBF,EAAiBE,SAIjB,IAAAL,EAAIM,UAAA,IAAAxB,EAAAyB,OACFP,EAAKM,aAAY,IAAOE,EAAPC,OAAjBC,IAAAV,EAAAM,UAAA,CACAN,SAAKE,eACHS,SAAUR,EACVS,WAAUT,EAAAA,WACVP,cAAYI,EAAKJ,gBAHuCI,EAAAP,cAAAO,EAAAL,WAIxDF,MAAAA,OAAaoB,MAAEC,EAASC,gBAAgBf,GACxCgB,QAAOC,OAAOJ,MAAMb,EAAKH,kBAL+B,GAMxDqB,MAAOD,OAAEA,MAAOJ,EAAMb,gBAAKF,GAC3BqB,SAAOF,OAAOJ,MAAMb,EAAKD,mBAP+B,KAW1DC,EAAKE,aAAakB,GAAG,aAAc,SAAUC,GAC3CtC,EAAiB,mCACbsC,GAAUA,EAAOC,QAArBvC,EAAcsC,2BAAeE,KAAAC,UAAAH,EAAAC,OAAAG,WAAA,SAAAJ,EAAAC,OAAAI,cAAA,IAAAL,EAAAC,OAAAK,YAE5Bb,EAAAc,gBAAA,SAAA5B,KAEFA,EANDM,UAAAuB,OAAA7B,EAAAV,WAAAU,EAAAX,SAAA,WAQAW,EAAe6B,uCAAuC7B,EAAAX,SAAM,IAAAW,EAAAV,YAC1DP,EAAAA,gBAAiB,cAAAiB,KAElB,MAHD8B,GAIA/C,EAAY+C,EAAAC,SACZhD,EAAAA,YAEEiB,EAAKgC,KAAKF,GAAV9B,EAAKgC,gBAAL,QAAAhC,GAEFc,EAAAA,GAAAA,QAASc,SAAgBK,GAC1BjC,EAAAkC,KAGClC,SAAUmC,GADZ,MAAA,CAMI,CAAEC,KAAM,UAAWL,QAASE,EAAKI,QAASrC,EAAKE,aAAagB,SAFhE,CAAAkB,KAASD,QAATJ,QAA4BE,EAAAI,QAAArC,EAAAE,aAAAc,OAC1B,CAAAoB,KACE,QAAAL,QAAAE,EAAAI,QAAArC,EAAAE,aAAAiB,OAAEiB,CAAAA,KAAM,WAARL,QAAAE,EAAAI,QAAArC,EAAAE,aAAAoC,WARHH,CAAAF,MASKG,EAAAA,GAAI,QAAN,SAAAG,GAAiBR,EAAOH,gBAAxB,SAAA5B,GAA+BqC,EAAO/B,WAFjCN,EAGLM,UAAAkC,MAAA,WAAEJ,EAAF,wBAAiBL,MACfK,EAAAA,aAAF,SAIJpC,MAAA8B,GACEhB,EAASc,EAAAA","file":"../modbus-server.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019 Klaus Landsdorf (https://bianco-royal.com/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n **/\n/**\n * Modbus Server node.\n * @module NodeRedModbusServer\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const modbus = require('jsmodbus')\n  const net = require('net')\n\n  const mbBasics = require('./modbus-basics')\n  const internalDebugLog = require('debug')('contribModbus:server')\n\n  function ModbusServer (config) {\n    RED.nodes.createNode(this, config)\n    const bufferFactor = 8\n\n    this.name = config.name\n    this.logEnabled = config.logEnabled\n    this.hostname = config.hostname || '0.0.0.0'\n    this.serverPort = parseInt(config.serverPort)\n    this.responseDelay = parseInt(config.responseDelay)\n    this.delayUnit = config.delayUnit\n\n    this.coilsBufferSize = parseInt(config.coilsBufferSize * bufferFactor)\n    this.holdingBufferSize = parseInt(config.holdingBufferSize * bufferFactor)\n    this.inputBufferSize = parseInt(config.inputBufferSize * bufferFactor)\n    this.discreteBufferSize = parseInt(config.discreteBufferSize * bufferFactor)\n\n    this.showErrors = config.showErrors\n\n    const node = this\n\n    node.netServer = null\n    node.modbusServer = null\n\n    mbBasics.setNodeStatusTo('initialized', node)\n\n    let modbusLogLevel = 'warn'\n    if (RED.settings.verbose) {\n      modbusLogLevel = 'debug'\n    }\n\n    try {\n      node.netServer = new net.Server()\n      node.modbusServer = new modbus.server.TCP(node.netServer, {\n        logLabel: 'ModbusServer',\n        logLevel: modbusLogLevel,\n        logEnabled: node.logEnabled,\n        responseDelay: mbBasics.calc_rateByUnit(node.responseDelay, node.delayUnit),\n        coils: Buffer.alloc(node.coilsBufferSize, 0),\n        holding: Buffer.alloc(node.holdingBufferSize, 0),\n        input: Buffer.alloc(node.inputBufferSize, 0),\n        discrete: Buffer.alloc(node.discreteBufferSize, 0)\n      })\n\n      node.modbusServer.on('connection', function (client) {\n        internalDebugLog('Modbus Server client connection')\n        if (client && client.socket) {\n          internalDebugLog('Modbus Server client to ' + JSON.stringify(client.socket.address()) + ' from ' + client.socket.remoteAddress + ' ' + client.socket.remotePort)\n        }\n        mbBasics.setNodeStatusTo('active', node)\n      })\n\n      node.netServer.listen(node.serverPort, node.hostname, () => {\n        internalDebugLog('Modbus Server listening on modbus://' + node.hostname + ':' + node.serverPort)\n        mbBasics.setNodeStatusTo('initialized', node)\n      })\n    } catch (err) {\n      internalDebugLog(err.message)\n      if (node.showErrors) {\n        node.warn(err)\n      }\n      mbBasics.setNodeStatusTo('error', node)\n    }\n\n    node.on('input', function (msg) {\n      node.send(buildMessage(msg))\n    })\n\n    function buildMessage (msg) {\n      return [\n        { type: 'holding', message: msg, payload: node.modbusServer.holding },\n        { type: 'coils', message: msg, payload: node.modbusServer.coils },\n        { type: 'input', message: msg, payload: node.modbusServer.input },\n        { type: 'discrete', message: msg, payload: node.modbusServer.discrete }\n      ]\n    }\n\n    node.on('close', function (done) {\n      mbBasics.setNodeStatusTo('closed', node)\n      if (node.netServer) {\n        node.netServer.close(() => {\n          internalDebugLog('Modbus Server closed')\n          done()\n        })\n      }\n      node.modbusServer = null\n    })\n  }\n\n  try {\n    RED.nodes.registerType('modbus-server', ModbusServer)\n  } catch (err) {\n    internalDebugLog(err.message)\n  }\n}\n"]}