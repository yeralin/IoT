{"version":3,"sources":["core/modbus-queue-core.js"],"names":["require","install","de","biancoroyal","modbus","queue","core","internalDebug","initQueue","node","clear","sendAllowed","sendToDeviceAllowed","unitSendingAllowed","step","set","bufferCommandList","checkQueuesAreEmpty","queueIsEmpty","get","length","sequentialDequeueCommand","nodesToWaitCount","serialUnit","parseInt","shift","Number","isInteger","noneCommandToSent","this","sendDataInParallel","sendDataPerDevice","queueLog","type","sendAllowedForNext","JSON","stringify","unitid","stateService","send","queueLength","delay","commandDelay","command","push","callModbus","msg","cb","cberr","dequeueCommand","state","actualServiceState","value","message","clienttype","getQueueNumber","payload","unit","unit_id","pushToQueueByUnitId","sendingListLength","queueUnit","info","indexOf","module","exports"],"mappings":"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","file":"../../core/modbus-queue-core.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019 Klaus Landsdorf (https://bianco-royal.com/)\n All rights reserved.\n node-red-contrib-modbus\n node-red-contrib-modbusio\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n'use strict'\nrequire('source-map-support').install()\n\nvar de = de || { biancoroyal: { modbus: { queue: { core: {} } } } } // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.queue.core.internalDebug = de.biancoroyal.modbus.queue.core.internalDebug || require('debug')('contribModbus:queue:core') // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.queue.core.core = de.biancoroyal.modbus.queue.core.core || require('./modbus-core') // eslint-disable-line no-use-before-define\n\nde.biancoroyal.modbus.queue.core.initQueue = function (node) {\n  node.bufferCommandList.clear()\n  node.sendAllowed.clear()\n  node.sendToDeviceAllowed = []\n  node.unitSendingAllowed = []\n\n  for (let step = 0; step <= 255; step++) {\n    node.bufferCommandList.set(step, [])\n    node.sendAllowed.set(step, true)\n  }\n}\n\nde.biancoroyal.modbus.queue.core.checkQueuesAreEmpty = function (node) {\n  let queueIsEmpty = true\n  for (let step = 0; step <= 255; step++) {\n    queueIsEmpty &= (node.bufferCommandList.get(step).length > 0)\n  }\n  return queueIsEmpty\n}\n\nde.biancoroyal.modbus.queue.core.sequentialDequeueCommand = function (node) {\n  const nodesToWaitCount = node.unitSendingAllowed.length\n  const serialUnit = parseInt(node.unitSendingAllowed.shift())\n  let noneCommandToSent = true\n\n  if (Number.isInteger(serialUnit) &&\n    node.bufferCommandList.get(serialUnit).length > 0) {\n    if (node.parallelUnitIdsAllowed) {\n      noneCommandToSent = this.sendDataInParallel(node, serialUnit, nodesToWaitCount)\n    } else {\n      noneCommandToSent = this.sendDataPerDevice(node, serialUnit, nodesToWaitCount)\n    }\n  } else {\n    node.queueLog(JSON.stringify({\n      type: 'queue check is not a unit',\n      unitid: serialUnit\n    }))\n  }\n\n  if (noneCommandToSent) {\n    node.stateService.send('EMPTY')\n  }\n}\n\nde.biancoroyal.modbus.queue.core.sendDataInParallel = function (node, serialUnit, nodesToWaitCount) {\n  let command = null\n  let noneCommandToSent = true\n\n  node.queueLog(JSON.stringify({\n    type: 'queue check',\n    unitid: serialUnit,\n    sendAllowed: node.sendAllowed.get(serialUnit),\n    queueLength: node.bufferCommandList.get(serialUnit).length\n  }))\n\n  if (node.sendAllowed.get(serialUnit)) {\n    command = node.bufferCommandList.get(serialUnit).shift()\n    if (command) {\n      node.sendAllowed.set(serialUnit, false)\n      node.queueLog(JSON.stringify({\n        type: 'serial sending and wait per unitid',\n        unitid: serialUnit,\n        // commandData: command,\n        queueLength: node.bufferCommandList.get(serialUnit).length,\n        sendAllowedForNext: node.sendAllowed.get(serialUnit),\n        delay: node.commandDelay\n      }))\n\n      if (node.bufferCommandList.get(serialUnit).length > 0) {\n        node.unitSendingAllowed.push(serialUnit)\n      }\n      noneCommandToSent = false\n      command.callModbus(node, command.msg, command.cb, command.cberr)\n    }\n  }\n\n  return noneCommandToSent\n}\n\nde.biancoroyal.modbus.queue.core.sendDataPerDevice = function (node, serialUnit, nodesToWaitCount) {\n  let command = null\n  let noneCommandToSent = true\n\n  node.queueLog(JSON.stringify({\n    type: 'queue check',\n    unitid: serialUnit,\n    sendAllowed: node.sendAllowed.get(serialUnit),\n    queueLength: node.bufferCommandList.get(serialUnit).length\n  }))\n\n  if (node.sendToDeviceAllowed.length === 0) {\n    command = node.bufferCommandList.get(serialUnit).shift()\n    if (command) {\n      node.sendToDeviceAllowed.push(serialUnit)\n      node.queueLog(JSON.stringify({\n        type: 'serial sending and wait',\n        unitid: serialUnit,\n        // commandData: command,\n        queueLength: node.bufferCommandList.get(serialUnit).length,\n        sendAllowedForNext: node.sendToDeviceAllowed.length,\n        delay: node.commandDelay\n      }))\n\n      if (node.bufferCommandList.get(serialUnit).length > 0) {\n        node.unitSendingAllowed.push(serialUnit)\n      }\n      noneCommandToSent = false\n      command.callModbus(node, command.msg, command.cb, command.cberr)\n    }\n  }\n\n  return noneCommandToSent\n}\n\nde.biancoroyal.modbus.queue.core.dequeueCommand = function (node) {\n  const state = node.actualServiceState\n\n  if (node.messageAllowedStates.indexOf(state.value) === -1) {\n    node.queueLog(JSON.stringify({\n      state: state.value,\n      message: 'dequeue command disallowed state',\n      delay: node.commandDelay\n    }))\n  } else {\n    node.queueLog(JSON.stringify({\n      state: state.value,\n      message: 'dequeue command ' + node.clienttype,\n      delay: node.commandDelay\n    }))\n\n    this.sequentialDequeueCommand(node)\n  }\n\n  if (this.checkQueuesAreEmpty(node)) {\n    node.stateService.send('EMPTY')\n  }\n}\n\nde.biancoroyal.modbus.queue.core.getQueueNumber = function (node, msg) {\n  const unit = parseInt(msg.payload.unitid)\n\n  if (Number.isInteger(unit)) {\n    return node.bufferCommandList.get(unit).length\n  } else {\n    return node.bufferCommandList.get(node.unit_id).length\n  }\n}\n\nde.biancoroyal.modbus.queue.core.pushToQueueByUnitId = function (node, callModbus, msg, cb, cberr) {\n  const unit = parseInt(msg.payload.unitid)\n\n  if (Number.isInteger(unit)) {\n    msg.queueUnit = unit\n    node.queueLog(JSON.stringify({\n      info: 'push to Queue by Unit-Id',\n      message: msg.payload,\n      unit: unit,\n      sendingListLength: node.unitSendingAllowed.length\n    }))\n\n    node.unitSendingAllowed.push(unit)\n    node.bufferCommandList.get(unit).push({ callModbus: callModbus, msg: msg, cb: cb, cberr: cberr })\n  } else {\n    msg.queueUnit = node.unit_id\n    node.queueLog(JSON.stringify({\n      info: 'push to Queue by default Unit-Id',\n      message: msg.payload,\n      unit: node.unit_id,\n      sendingListLength: node.unitSendingAllowed.length\n    }))\n\n    if (node.unitSendingAllowed.indexOf(node.unit_id) === -1) {\n      node.unitSendingAllowed.push(node.unit_id)\n    }\n\n    node.bufferCommandList.get(node.unit_id).push({ callModbus: callModbus, msg: msg, cb: cb, cberr: cberr })\n  }\n}\n\nmodule.exports = de.biancoroyal.modbus.queue.core\n"]}