{"version":3,"sources":["modbus-client.js"],"names":["module","exports","RED","require","install","coreModbusClient","coreModbusQueue","node","stateService","config","mbBasics","createNode","this","ModbusRTU","minCommandDelayMilliseconds","defaultUnitId","bufferCommands","serialConnectionDelayTimeMS","reconnectTimeMS","tcpHost","clienttype","parseInt","tcpPort","tcpType","serialDatabits","serialPort","serialBaudrate","serialStopbits","serialConnectionDelay","serialType","unit_id","commandDelay","clientTimeout","reconnectTimeout","parallelUnitIdsAllowed","verboseWarn","logMessage","settings","verbose","serverInfo","verboseLog","isFirstInitOfConnection","closingModbus","client","Map","bufferCommandList","sendAllowed","unitSendingAllowed","sendToDeviceAllowed","messagesAllowedStates","messageAllowedStates","stateMachine","createStateMachineService","actualServiceState","initialState","actualServiceStateBefore","startStateService","setUnitIdFromPayload","msg","unit","payload","unitid","Number","isInteger","setID","queueUnitId","checkUnitId","isNaN","updateServerinfo","queueLog","subscribe","state","stateLog","stateLogEnabled","value","initQueue","setTimeout","connectClient","error","err","emit","send","matches","dequeueCommand","JSON","stringify","reconnectOnTimeout","close","message","timeoutTimeMS","Error","connectC701","autoOpen","then","setTCPConnected","modbusTcpErrorHandling","connectTelnet","port","setTCPConnectionOptions","connectTcpRTUBuffered","connectTCP","dataBits","stopBits","parity","connectAsciiSerial","serialPortOptions","setSerialConnectionOptions","baudRate","serialParity","modbusSerialErrorHandling","connectRTUBuffered","modbusSerialDebug","modbusErrorHandling","networkErrors","includes","errno","_port","on","onModbusClose","indexOf","queueNumber","getQueueNumber","pushToQueueByUnitId","readModbus","cb","cberr","info","get","queueUnit","length","queueLength","writeModbus","deviceId","shift","set","setMaxListeners","invalidPayloadIn","internalDebug","setNewNodeSettings","unlimitedListeners","done","registerForModbus","modbusNode","id","keys","registeredNodeList","deregisterForModbus","Object","auth","needsPermission","req","res","list","ports","json"],"mappings":"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","file":"../modbus-client.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019 Klaus Landsdorf (https://bianco-royal.com/)\n Copyright 2016 - Jason D. Harper, Argonne National Laboratory\n Copyright 2015,2016 - Mika Karaila, Valmet Automation Inc.\n All rights reserved.\n node-red-contrib-modbus\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n/**\n * Modbus connection node.\n * @module NodeRedModbusClient\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const coreModbusClient = require('./core/modbus-client-core')\n  const coreModbusQueue = require('./core/modbus-queue-core')\n\n  function ModbusClientNode (config) {\n    RED.nodes.createNode(this, config)\n\n    // create an empty modbus client\n    const ModbusRTU = require('modbus-serial')\n\n    const unlimitedListeners = 0\n    const minCommandDelayMilliseconds = 1\n    const defaultUnitId = 1\n    const serialConnectionDelayTimeMS = 500\n    const timeoutTimeMS = 1000\n    const reconnectTimeMS = 2000\n\n    this.clienttype = config.clienttype\n    this.bufferCommands = config.bufferCommands\n    this.stateLogEnabled = config.stateLogEnabled\n\n    this.tcpHost = config.tcpHost\n    this.tcpPort = parseInt(config.tcpPort) || 502\n    this.tcpType = config.tcpType\n\n    this.serialPort = config.serialPort\n    this.serialBaudrate = config.serialBaudrate\n    this.serialDatabits = config.serialDatabits\n    this.serialStopbits = config.serialStopbits\n    this.serialParity = config.serialParity\n    this.serialType = config.serialType\n    this.serialConnectionDelay = parseInt(config.serialConnectionDelay) || serialConnectionDelayTimeMS\n\n    this.unit_id = parseInt(config.unit_id) || defaultUnitId\n    this.commandDelay = parseInt(config.commandDelay) || minCommandDelayMilliseconds\n    this.clientTimeout = parseInt(config.clientTimeout) || timeoutTimeMS\n    this.reconnectTimeout = parseInt(config.reconnectTimeout) || reconnectTimeMS\n    this.reconnectOnTimeout = config.reconnectOnTimeout\n    this.parallelUnitIdsAllowed = config.parallelUnitIdsAllowed\n\n    const node = this\n    node.isFirstInitOfConnection = true\n    node.closingModbus = false\n    node.client = null\n    node.bufferCommandList = new Map()\n    node.sendAllowed = new Map()\n    node.unitSendingAllowed = []\n    node.sendToDeviceAllowed = []\n    node.messageAllowedStates = coreModbusClient.messagesAllowedStates\n    node.serverInfo = ''\n\n    node.stateMachine = null\n    node.stateService = null\n    node.stateMachine = coreModbusClient.createStateMachineService()\n    node.actualServiceState = node.stateMachine.initialState\n    node.actualServiceStateBefore = node.actualServiceState\n    node.stateService = coreModbusClient.startStateService(node.stateMachine)\n\n    node.setUnitIdFromPayload = function (msg) {\n      const unit = parseInt(msg.payload.unitid)\n\n      if (Number.isInteger(unit)) {\n        node.client.setID(unit)\n        msg.queueUnitId = unit\n      } else {\n        if (!coreModbusClient.checkUnitId(node.unit_id, node.clienttype)) {\n          node.unit_id = defaultUnitId\n        }\n        node.client.setID(node.unit_id)\n        msg.queueUnitId = node.unit_id\n      }\n    }\n\n    if (Number.isNaN(node.unit_id) || !coreModbusClient.checkUnitId(node.unit_id, node.clienttype)) {\n      node.unit_id = defaultUnitId\n    }\n\n    node.updateServerinfo = function () {\n      if (node.clienttype === 'tcp') {\n        node.serverInfo = ' TCP@' + node.tcpHost + ':' + node.tcpPort\n      } else {\n        node.serverInfo = ' Serial@' + node.serialPort + ':' + node.serialBaudrate + 'bit/s'\n      }\n      node.serverInfo += ' default Unit-Id: ' + node.unit_id\n    }\n\n    function verboseWarn (logMessage) {\n      if (RED.settings.verbose) {\n        node.warn('Client -> ' + logMessage + node.serverInfo)\n      }\n    }\n\n    function verboseLog (logMessage) {\n      if (RED.settings.verbose) {\n        coreModbusClient.internalDebug('Client -> ' + logMessage + node.serverInfo)\n      }\n    }\n\n    function stateLog (logMessage) {\n      if (node.stateLogEnabled) {\n        verboseLog(logMessage)\n      }\n    }\n\n    node.queueLog = function (logMessage) {\n      if (node.bufferCommands) {\n        verboseLog(logMessage)\n      }\n    }\n\n    node.stateService.subscribe(state => {\n      node.actualServiceStateBefore = node.actualServiceState\n      node.actualServiceState = state\n      stateLog(state.value)\n\n      if (state.matches('init')) {\n        node.updateServerinfo()\n        coreModbusQueue.initQueue(node)\n\n        try {\n          if (node.isFirstInitOfConnection) {\n            node.isFirstInitOfConnection = false\n            setTimeout(node.connectClient, serialConnectionDelayTimeMS)\n          } else {\n            setTimeout(node.connectClient, node.reconnectTimeout)\n          }\n        } catch (err) {\n          node.error(err, { payload: 'client connection error' })\n        }\n\n        verboseWarn('reconnect in ' + node.reconnectTimeout + ' ms')\n        node.emit('mbinit')\n      }\n\n      if (state.matches('connected')) {\n        node.emit('mbconnected')\n        node.stateService.send('ACTIVATE')\n      }\n\n      if (state.matches('activated')) {\n        node.emit('mbactive')\n        if (node.bufferCommands) {\n          node.stateService.send('QUEUE')\n        }\n      }\n\n      if (state.matches('queueing')) {\n        setTimeout(() => {\n          coreModbusQueue.dequeueCommand(node)\n        }, node.commandDelay)\n        node.emit('mbqueue')\n      }\n\n      if (state.matches('opened')) {\n        node.emit('mbopen')\n      }\n\n      if (state.matches('closed')) {\n        node.emit('mbclosed')\n        node.stateService.send('BREAK')\n      }\n\n      if (state.matches('failed')) {\n        node.emit('mberror', 'FSM Reset On State ' + JSON.stringify(state))\n        node.stateService.send('BREAK')\n      }\n\n      if (state.matches('broken')) {\n        node.emit('mbbroken')\n        if (node.reconnectOnTimeout) {\n          if (node.reconnectTimeout <= 0) {\n            node.reconnectTimeout = reconnectTimeMS\n          }\n          verboseWarn('try to reconnect by init in ' + node.reconnectTimeout + ' ms')\n          setTimeout(() => {\n            node.stateService.send('INIT')\n          }, node.reconnectTimeout)\n        } else {\n          verboseWarn('stay active on broken state without reconnecting')\n          node.stateService.send('ACTIVATE')\n        }\n      }\n    })\n\n    node.connectClient = function () {\n      if (node.client) {\n        try {\n          node.client.close(function () {\n            verboseLog('connection closed')\n          })\n        } catch (err) {\n          verboseLog(err.message)\n        }\n      }\n      node.client = null\n      node.client = new ModbusRTU()\n\n      if (!node.clientTimeout) {\n        node.clientTimeout = timeoutTimeMS\n      }\n\n      if (!node.reconnectTimeout) {\n        node.reconnectTimeout = reconnectTimeMS\n      }\n\n      if (node.clienttype === 'tcp') {\n        if (!coreModbusClient.checkUnitId(node.unit_id, node.clienttype)) {\n          node.error(new Error('wrong unit-id (0..255)'), { payload: node.unit_id })\n          node.stateService.send('FAILURE')\n          return\n        }\n\n        switch (node.tcpType) {\n          case 'C701':\n            verboseLog('C701 port UDP bridge')\n            node.client.connectC701(node.tcpHost, {\n              port: node.tcpPort,\n              autoOpen: true\n            }).then(node.setTCPConnectionOptions)\n              .then(node.setTCPConnected)\n              .catch(node.modbusTcpErrorHandling)\n            break\n          case 'TELNET':\n            verboseLog('Telnet port')\n            node.client.connectTelnet(node.tcpHost, {\n              port: node.tcpPort,\n              autoOpen: true\n            }).then(node.setTCPConnectionOptions)\n              .catch(node.modbusTcpErrorHandling)\n            break\n          case 'TPC-RTU-BUFFERED':\n            verboseLog('TCP RTU buffered port')\n            node.client.connectTcpRTUBuffered(node.tcpHost, {\n              port: node.tcpPort,\n              autoOpen: true\n            }).then(node.setTCPConnectionOptions)\n              .catch(node.modbusTcpErrorHandling)\n            break\n          default:\n            verboseLog('TCP port')\n            node.client.connectTCP(node.tcpHost, {\n              port: node.tcpPort,\n              autoOpen: true\n            }).then(node.setTCPConnectionOptions)\n              .catch(node.modbusTcpErrorHandling)\n        }\n      } else {\n        if (!coreModbusClient.checkUnitId(node.unit_id, node.clienttype)) {\n          node.error(new Error('wrong unit-id serial (1..247)'), { payload: node.unit_id })\n          node.stateService.send('FAILURE')\n          return\n        }\n\n        if (!node.serialConnectionDelay) {\n          node.serialConnectionDelay = serialConnectionDelayTimeMS\n        }\n\n        if (!node.serialPort) {\n          node.error(new Error('wrong serial port'), { payload: node.serialPort })\n          node.stateService.send('FAILURE')\n          return\n        }\n\n        const serialPortOptions = {\n          baudRate: parseInt(node.serialBaudrate),\n          dataBits: parseInt(node.serialDatabits),\n          stopBits: parseInt(node.serialStopbits),\n          parity: node.serialParity,\n          autoOpen: false\n        }\n\n        switch (node.serialType) {\n          case 'ASCII':\n            verboseLog('ASCII port serial')\n            node.client.connectAsciiSerial(node.serialPort, serialPortOptions).then(node.setSerialConnectionOptions)\n              .catch(node.modbusSerialErrorHandling)\n            break\n          case 'RTU':\n            verboseLog('RTU port serial')\n            node.client.connectRTU(node.serialPort, serialPortOptions).then(node.setSerialConnectionOptions)\n              .catch(node.modbusSerialErrorHandling)\n            break\n          default:\n            verboseLog('RTU buffered port serial')\n            node.client.connectRTUBuffered(node.serialPort, serialPortOptions).then(node.setSerialConnectionOptions)\n              .catch(node.modbusSerialErrorHandling)\n            break\n        }\n      }\n    }\n\n    node.setTCPConnectionOptions = function () {\n      node.client.setID(node.unit_id)\n      node.client.setTimeout(node.clientTimeout)\n      node.stateService.send('CONNECT')\n    }\n\n    node.setTCPConnected = function () {\n      coreModbusClient.modbusSerialDebug('modbus tcp connected on ' + node.tcpHost)\n    }\n\n    node.setSerialConnectionOptions = function () {\n      node.stateService.send('OPENSERIAL')\n      setTimeout(node.openSerialClient, parseInt(node.serialConnectionDelay))\n    }\n\n    node.modbusErrorHandling = function (err) {\n      if (err.message) {\n        coreModbusClient.modbusSerialDebug('modbusErrorHandling:' + err.message)\n      } else {\n        coreModbusClient.modbusSerialDebug('modbusErrorHandling:' + JSON.stringify(err))\n      }\n      if (err.errno && coreModbusClient.networkErrors.includes(err.errno)) {\n        node.stateService.send('FAILURE')\n      }\n    }\n\n    node.modbusTcpErrorHandling = function (err) {\n      if (err.message) {\n        coreModbusClient.modbusSerialDebug('modbusTcpErrorHandling:' + err.message)\n      } else {\n        coreModbusClient.modbusSerialDebug('modbusTcpErrorHandling:' + JSON.stringify(err))\n      }\n      if (err.errno && coreModbusClient.networkErrors.includes(err.errno)) {\n        node.stateService.send('FAILURE')\n      }\n    }\n\n    node.modbusSerialErrorHandling = function (err) {\n      if (err.message) {\n        coreModbusClient.modbusSerialDebug('modbusSerialErrorHandling:' + err.message)\n      } else {\n        coreModbusClient.modbusSerialDebug('modbusSerialErrorHandling:' + JSON.stringify(err))\n      }\n      node.stateService.send('FAILURE')\n    }\n\n    node.openSerialClient = function () {\n      // some delay for windows\n      if (node.actualServiceState.value === 'opened') {\n        verboseLog('time to open Unit ' + node.unit_id)\n        coreModbusClient.modbusSerialDebug('modbus connection opened')\n        node.client.setID(node.unit_id)\n        node.client.setTimeout(parseInt(node.clientTimeout))\n        node.client._port.on('close', node.onModbusClose)\n        node.stateService.send('CONNECT')\n      } else {\n        verboseLog('wrong state on connect serial ' + node.actualServiceState.value)\n        coreModbusClient.modbusSerialDebug('modbus connection not opened state is %s', node.actualServiceState.value)\n        node.stateService.send('FAILURE')\n      }\n    }\n\n    node.onModbusClose = function () {\n      verboseWarn('modbus closed port')\n      coreModbusClient.modbusSerialDebug('modbus closed port')\n      node.stateService.send('CLOSE')\n    }\n\n    node.on('readModbus', function (msg, cb, cberr) {\n      const state = node.actualServiceState\n\n      if (node.messageAllowedStates.indexOf(state.value) === -1) {\n        cberr(new Error('FSM Not Ready To Read At State ' + state.value), msg)\n        return\n      }\n\n      if (node.bufferCommands) {\n        msg.queueNumber = coreModbusQueue.getQueueNumber(node, msg)\n        coreModbusQueue.pushToQueueByUnitId(node, coreModbusClient.readModbus, msg, cb, cberr)\n        node.stateService.send('QUEUE')\n\n        node.queueLog(JSON.stringify({\n          info: 'queue read msg',\n          message: msg.payload,\n          state: state.value,\n          queueLength: node.bufferCommandList.get(msg.queueUnit).length\n        }))\n      } else {\n        coreModbusClient.readModbus(node, msg, cb, cberr)\n      }\n    })\n\n    node.on('writeModbus', function (msg, cb, cberr) {\n      const state = node.actualServiceState\n\n      if (node.messageAllowedStates.indexOf(state.value) === -1) {\n        cberr(new Error('FSM Not Ready To Write At State ' + state.value), msg)\n        return\n      }\n\n      if (node.bufferCommands) {\n        msg.queueNumber = coreModbusQueue.getQueueNumber(node, msg)\n        coreModbusQueue.pushToQueueByUnitId(node, coreModbusClient.writeModbus, msg, cb, cberr)\n        node.stateService.send('QUEUE')\n\n        node.queueLog(JSON.stringify({\n          info: 'queue write msg',\n          message: msg.payload,\n          state: state.value,\n          queueLength: node.bufferCommandList.get(msg.queueUnit).length\n        }))\n      } else {\n        coreModbusClient.writeModbus(node, msg, cb, cberr)\n      }\n    })\n\n    node.activateSending = function (msg) {\n      const deviceId = node.sendToDeviceAllowed.shift()\n      if (node.bufferCommands) {\n        node.sendAllowed.set(msg.queueUnit, true)\n\n        node.queueLog(JSON.stringify({\n          info: 'queue response activate sending',\n          message: msg.payload,\n          queueLength: node.bufferCommandList.length,\n          serialUnitId: deviceId\n        }))\n      }\n      node.stateService.send('ACTIVATE')\n    }\n\n    verboseLog('initialized')\n    node.setMaxListeners(unlimitedListeners)\n\n    node.on('reconnect', function () {\n      node.stateService.send('FAILURE')\n      node.stateService.send('CLOSE')\n    })\n\n    node.on('dynamicReconnect', function (msg) {\n      if (mbBasics.invalidPayloadIn(msg)) {\n        throw new Error('Message Or Payload Not Valid')\n      }\n\n      coreModbusClient.internalDebug('Dynamic Reconnect Parameters ' + JSON.stringify(msg.payload))\n      coreModbusClient.setNewNodeSettings(node, msg)\n      coreModbusClient.internalDebug('Dynamic Reconnect Starts on actual state ' + node.actualServiceState.value)\n      node.stateService.send('CLOSE')\n    })\n\n    node.on('close', function (done) {\n      node.stateService.send('FAILURE')\n      node.stateService.send('CLOSE')\n      node.stateService.send('STOP')\n      verboseLog('close node')\n      if (node.client) {\n        node.client.close(function () {\n          verboseLog('connection closed')\n          done()\n        }).catch(function (err) {\n          verboseLog(err.message)\n          done()\n        })\n      } else {\n        done()\n      }\n    })\n\n    // handle using as config node\n    node.registeredNodeList = {}\n\n    node.registerForModbus = function (modbusNode) {\n      node.registeredNodeList[modbusNode.id] = modbusNode\n      if (Object.keys(node.registeredNodeList).length === 1) {\n        node.closingModbus = false\n        node.stateService.send('INIT')\n      }\n    }\n\n    node.deregisterForModbus = function (modbusNode, done) {\n      delete node.registeredNodeList[modbusNode.id]\n\n      if (node.closingModbus) {\n        done()\n      }\n      if (Object.keys(node.registeredNodeList).length === 0) {\n        node.closingModbus = true\n        if (node.client) {\n          node.client.close(function () {\n            node.stateService.send('CLOSE')\n            node.stateService.send('BREAK')\n            node.stateService.send('STOP')\n            done()\n          }).catch(function (err) {\n            node.stateService.send('FAILURE')\n            node.stateService.send('STOP')\n            verboseLog(err.message)\n            done()\n          })\n        } else {\n          done()\n        }\n      } else {\n        done()\n      }\n    }\n  }\n\n  RED.nodes.registerType('modbus-client', ModbusClientNode)\n\n  RED.httpAdmin.get('/modbus/serial/ports', RED.auth.needsPermission('serial.read'), function (req, res) {\n    const SerialPort = require('serialport')\n    SerialPort.list().then(ports => {\n      res.json(ports)\n    }).catch(err => {\n      coreModbusClient.internalDebug(err.message)\n    })\n  })\n}\n"]}