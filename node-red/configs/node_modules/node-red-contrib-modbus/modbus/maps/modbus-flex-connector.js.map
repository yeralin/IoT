{"version":3,"sources":["modbus-flex-connector.js"],"names":["module","exports","RED","require","install","internalDebugLog","nodes","registerType","createNode","this","config","name","maxReconnectsPerMinute","emptyQueue","showStatusActivities","showErrors","mbBasics","connection","getNode","server","node","modbusClient","registerForModbus","on","msg","invalidPayloadIn","setNodeStatusTo","actualServiceState","payload","emit"],"mappings":"aAaAA,OAAOC,QAAU,SAAUC,GAEzBC,QAAQ,sBAAsBC,UAFhCJ,IAAOC,EAAUE,QAAUD,mBACzBG,EAAAF,QAAA,QAAAA,CAAA,gCA4CKD,EAAAI,MAAAC,aAAA,wBA3CLJ,SAA8BC,GAK5BF,EAAII,MAAME,WAAWC,KAAMC,GAE3BD,KAAKE,KAAOD,EAAOC,KALrBF,KAAMJ,uBAA2BK,EAARE,wBAAiB,EAOxCH,KAAKI,WAAaH,EAAOG,WAL3BJ,KAAAK,qBAA8BJ,EAAQI,qBACpCZ,KAAII,WAAME,EAAVO,WAEAN,KAAKE,WAAa,KAElB,IAAKE,EAAAA,KACLG,EAAKF,gBAAL,UAAmCA,GAEnC,IAAKG,EAAaf,EAAlBI,MAAAY,QAAAR,EAAAS,QAEMC,IAONC,EAAaC,kBAAkBF,GAH/BJ,EAAKK,uBAAcD,EAAAC,GAElBD,EAAAG,GAAA,QAAA,SAAAC,GAKKR,EAASS,iBAAiBD,IAA1BR,EAASS,SAITL,EAACC,sBACHL,EAAAU,gBAAAL,EAAAM,mBAAAP,GAGEA,EAAIQ,QAACd,eACPE,EAASU,qBAA6BC,KAAAA,UAAAA,EAAoBP,UAC3DI,EAAAI,QAAAf,WAAAO,EAAAP,WAKCQ,EAAaQ,KAAK,mBAAoBL,IAFtCnB,EAAAA,MAAAA,IAAAA,MAAiB,sCAA0CuB","file":"../modbus-flex-connector.js","sourcesContent":["/**\n Copyright (c) 2017,2018 Klaus Landsdorf (https://bianco-royal.com/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n/**\n * Modbus flexible Getter node.\n * @module NodeRedModbusFlexGetter\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const internalDebugLog = require('debug')('contribModbus:flex:connector')\n\n  function ModbusFlexConnector (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.maxReconnectsPerMinute = config.maxReconnectsPerMinute || 4\n    this.emptyQueue = config.emptyQueue\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n    this.connection = null\n\n    const node = this\n    mbBasics.setNodeStatusTo('waiting', node)\n\n    const modbusClient = RED.nodes.getNode(config.server)\n    if (!modbusClient) {\n      return\n    }\n    modbusClient.registerForModbus(node)\n    mbBasics.initModbusClientEvents(node, modbusClient)\n\n    node.on('input', function (msg) {\n      if (mbBasics.invalidPayloadIn(msg)) {\n        return\n      }\n\n      if (!modbusClient.client) {\n        return\n      }\n\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo(modbusClient.actualServiceState, node)\n      }\n\n      if (msg.payload.connectorType) {\n        internalDebugLog('dynamicReconnect: ' + JSON.stringify(msg.payload))\n        msg.payload.emptyQueue = node.emptyQueue\n        modbusClient.emit('dynamicReconnect', msg)\n      } else {\n        node.error(new Error('Payload Not Valid - Connector Type'), msg)\n      }\n    })\n  }\n\n  RED.nodes.registerType('modbus-flex-connector', ModbusFlexConnector)\n}\n"]}